<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  <subtitle>Blog</subtitle>
  <link href="https://jrr997.github.io/blog/atom.xml" rel="self"/>
  
  <link href="https://jrr997.github.io/blog/"/>
  <updated>2021-03-21T15:07:43.520Z</updated>
  <id>https://jrr997.github.io/blog/</id>
  
  <author>
    <name>Zack Chang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS经典面试题Foo().getname()</title>
    <link href="https://jrr997.github.io/blog/2021/03/21/%E9%9D%A2%E8%AF%95%E9%A2%981/"/>
    <id>https://jrr997.github.io/blog/2021/03/21/%E9%9D%A2%E8%AF%95%E9%A2%981/</id>
    <published>2021-03-21T15:05:42.000Z</published>
    <updated>2021-03-21T15:07:43.520Z</updated>
    
    <content type="html"><![CDATA[<h5 id="文章摘要：解读new-Foo-getname"><a href="#文章摘要：解读new-Foo-getname" class="headerlink" title="文章摘要：解读new Foo().getname()"></a>文章摘要：解读new Foo().getname()<a id="more"></a></h5><h1 id="JS经典面试题Foo-getname"><a href="#JS经典面试题Foo-getname" class="headerlink" title="JS经典面试题Foo().getname()"></a>JS经典面试题Foo().getname()</h1><p>题目如下：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>{</span><br><span class="line">    getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">};</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">};</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">};</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Foo.getName(); </span><br><span class="line">getName(); </span><br><span class="line">Foo().getName(); </span><br><span class="line">getName(); </span><br><span class="line"><span class="keyword">new</span> Foo.getName();</span><br><span class="line"><span class="keyword">new</span> Foo().getName();</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName();</span><br></pre></td></tr></tbody></table></figure><p>输出看结果：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Foo.getName(); <span class="comment">//2</span></span><br><span class="line">getName(); <span class="comment">//4</span></span><br><span class="line">Foo().getName(); <span class="comment">//1</span></span><br><span class="line">getName(); <span class="comment">//1</span></span><br><span class="line"><span class="keyword">new</span> Foo.getName(); <span class="comment">//2</span></span><br><span class="line"><span class="keyword">new</span> Foo().getName(); <span class="comment">//3</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName(); <span class="comment">//3</span></span><br></pre></td></tr></tbody></table></figure><p>其中最难理解的是有关new的最后三道题(5、6、7题)，因此先从这三道题说起。</p><p>这三道题考的是运算符优先级，先来看三道题是如何执行的。</p><h4 id="new-Foo-getName"><a href="#new-Foo-getName" class="headerlink" title="new Foo.getName();"></a>new Foo.getName();</h4><p><code>new (Foo.getName)()</code>:先获取<code>function Foo.getName</code>，再<code>new</code>这个<code>function</code>，因此输出2</p><h4 id="new-Foo-getName-1"><a href="#new-Foo-getName-1" class="headerlink" title="new Foo().getName();"></a>new Foo().getName();</h4><p>先<code>new Foo()</code>得到一个实例对象，然后执行实例中的<code>getName()</code>方法，因为实例中没有这个方法，但原型上有，因此执行的是<code>Foo.prototype.getName</code>，输出3</p><p><strong>与上一题相比较的话就产生一个疑惑，为什么这个会先<code>new</code>，而上一题是后<code>new</code>，这个问题待会分析。</strong></p><h4 id="new-new-Foo-getName"><a href="#new-new-Foo-getName" class="headerlink" title="new new Foo().getName();"></a>new new Foo().getName();</h4><p>如果看不懂上面两题，这一题也肯定看不懂，因此对这题先做了解就好。</p><p>首先执行中间的<code>new Foo()</code>得到一个实例对象(假设为foo),再次强调<code>foo</code>是一个对象,此时变成了<code>new foo.getName()</code></p><p>接着执行<code>foo.getName</code>获取到foo对象中的<code>getName</code>属性，实则就是<code>Foo.prototype.getName</code></p><p>最后执行<code>new</code>，相当于<code>new Foo.prototype.getName</code>，因此输出3</p><h4 id="解惑：为什么第5题后new，第6题先new"><a href="#解惑：为什么第5题后new，第6题先new" class="headerlink" title="解惑：为什么第5题后new，第6题先new"></a>解惑：为什么第5题后new，第6题先new</h4><p>这与javascript运算符优先级有关，下面简单介绍一下运算符的优先级。</p><p>详细的运算符优先级表格在这里：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence%E3%80%82">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence。</a></p><p>在这个题目中我们只需要关注题目出现过的运算符，有三个：函数调用<code>()</code>、成员访问<code>.</code>和<code>new</code>关键字，巧的是这三个运算符的优先级相同(优先级为20)。</p><p>这里要注意一个细节，<code>new</code>(带参数列表)的优先级为20，<code>new</code>无参数列表的优先级为19，这也是判断第5和6题的关键。</p><p>什么是带参数列表？简单的说就是<code>new Foo()</code>，而无参数列表是<code>new Foo</code>，没有括号，综合上面的说法，<code>new Foo</code>比函数调用<code>()</code>、成员访问<code>.</code>的优先级低。</p><p>现在我们可以彻底理解第5题new Foo.getName()的执行顺序，为什么是后new？</p><p>我们可以分析<code>new Foo.getName()</code>可能的执行顺序：</p><ol><li>先<code>new Foo</code>返回的是一个<code>foo</code>实例对象，再执行<code>foo.getName()</code>,最后输出3。<ul><li>这里第一步的优先级为19，第二步为20</li></ul></li><li>与正确答案一样，先<code>Foo.getName</code>再<code>new</code>，最后输出2。<ul><li>这里第一步的优先级为20，第二步的优先级为20.</li></ul></li></ol><p>比较两种顺序的第一步，答案很明显，下面的执行顺序优先级更高。</p><h4 id="再来分析第6题，为什么先new？"><a href="#再来分析第6题，为什么先new？" class="headerlink" title="再来分析第6题，为什么先new？"></a>再来分析第6题，为什么先new？</h4><p><code>new Foo().getName() </code></p><p>可能的执行顺序：</p><ol><li>先<code>new Foo()</code>得到实例对象<code>foo</code>，再执行<code>foo.getName()</code>，输出3<ul><li>第一步的优先级为20，第二步为20</li></ul></li><li>先执行<code>Foo().getName</code>得到一个<code>Foo</code>的静态方法，再<code>new</code>这个静态方法，最后输出2<ul><li>第一步的优先级是20，第二部的优先级也是20</li></ul></li></ol><p>这是什么情况？既然大家的第一步优先级都是20，那为什么第一种是正确的？</p><p>这里要考虑运算符的关联性，详细可以看上面发的MDN链接。简单地说，一个运算式可能会从左到右执行，也可能从右到左执行，取决于运算符的关联性。而在这个例子中，<code>new</code>是没有关联性的，函数调用<code>()</code>、成员访问<code>.</code>的关联性是从左到右，这意味优先级相同时，<code>new Foo().getName() </code>应该从左到右执行。左边的第一个运算符是<code>new</code>，当然是先执行<code>new</code>。</p><p>到目前为止，我们已经搞懂了第5题和第6题，那么最后一题相信大家思考一下都能得到答案。，而1-4题也是比较简单的题目。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>解题的思路是运算符的优先级，以及优先级相同时考虑关联性。</p>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;文章摘要：解读new-Foo-getname&quot;&gt;&lt;a href=&quot;#文章摘要：解读new-Foo-getname&quot; class=&quot;headerlink&quot; title=&quot;文章摘要：解读new Foo().getname()&quot;&gt;&lt;/a&gt;文章摘要：解读new Foo().getname()&lt;/h5&gt;</summary>
    
    
    
    <category term="基础" scheme="https://jrr997.github.io/blog/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="面试" scheme="https://jrr997.github.io/blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>HTTP2</title>
    <link href="https://jrr997.github.io/blog/2021/03/12/HTTP2/"/>
    <id>https://jrr997.github.io/blog/2021/03/12/HTTP2/</id>
    <published>2021-03-12T06:20:38.000Z</published>
    <updated>2021-03-12T06:24:29.150Z</updated>
    
    <content type="html"><![CDATA[<h5 id="文章摘要：了解HTTP2的新特性"><a href="#文章摘要：了解HTTP2的新特性" class="headerlink" title="文章摘要：了解HTTP2的新特性"></a>文章摘要：了解HTTP2的新特性<a id="more"></a></h5><h1 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>Q：为什么要HTTP2？</strong></p><p><strong>A：因为HTTP1.x有缺陷。</strong></p><ul><li><p>连接无法复用，一个TCP连接对应一个http请求。每次请求都要新建一个TCP连接，而TCP连接要经过三次握手和慢启动，效率较低。</p><ul><li>HTTP1.0中，每个请求都要重新建立一个连接。</li></ul></li><li><p>队头阻塞</p><ul><li>HTTP1.1加入了keep-alive，虽然可以在同一个TCP连接中发送多个HTTP请求，但是在同一时间、同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞。这意味着某个请求的超时会导致后面的请求阻塞(线头阻塞)，HTTP1.1发送请求是单线程的。</li></ul></li><li><p>头部开销大</p><p>在HTTP1.x，每次请求都会在header中携带大量的信息，而这些信息有很多都是重复的，这方面有很大的优化空间(HTTP2.0就优化了这方面)。</p></li></ul><p><strong>HTTP2旨在在HTTP1.x的基础上，改善web性能，可以认为是在HTTP1.x的基础上进行扩展。</strong></p><p>那么HTTP2做了什么工作呢？</p><p><strong>一句话概括就是HTTP2的新特性：二进制分帧、多路复用、Header压缩、服务端推送。</strong></p><h3 id="1-二进制分帧"><a href="#1-二进制分帧" class="headerlink" title="1.二进制分帧"></a>1.二进制分帧</h3><p>这里有两个重要概念：<strong>二进制</strong>和<strong>分帧</strong></p><h4 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h4><p>Q：为什么是二进制？</p><p>A：HTTP2采用二进制传输，而HTTP1.x传输的是文本，由于二进制只有0和1，因此数据解析起来更高效。</p><h4 id="分帧"><a href="#分帧" class="headerlink" title="分帧"></a>分帧</h4><p>Q1：什么是分帧？</p><p>A1：这里要先了解几个概念：</p><p><strong>流</strong>：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（1、2…N）；</p><p><strong>消息</strong>：相当于HTTP请求，由一个或多个帧组成;</p><p><strong>帧</strong>：分为<strong>Header帧</strong>和<strong>Data帧</strong>，<strong>Header帧</strong>保存的是HTTP请求头部的信息，<strong>Data帧</strong>保存的是数据信息，包括请求参数和响应结果。帧是最小的传输单位，帧的首部会标识出当前帧所属的流，因为HTTP2把一个请求分为多个帧传输，那么如何区分某个帧是哪个请求呢？这个标志的流用以区分不同的HTTP请求。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://image.fundebug.com/2019-03-06-2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>总结一下：消息(初步理解为HTTP请求)在流中传输，而消息又拆分成多个帧用来传输。当然一个流可以传输多个信息，只要在帧的首部进行区分就行。</p><p>Q2：为什么要分帧？</p><p>A2：分帧主要用在多路复用中，解决HTTP1.x中数据传输阻塞的问题，下面有更具体的描述。</p><h3 id="2-多路复用"><a href="#2-多路复用" class="headerlink" title="2.多路复用"></a>2.多路复用</h3><ul><li><strong>双向传输</strong>：在同一个TCP连接中可以传输任意数量的双向数据流，这就突破了HTTP1.1对HTTP请求数量的限制。</li><li><strong>一个TCP连接</strong>：同一域名下数据的传输在一个TCP连接中完成。在HTTP1.x中，一个网页可能会同时与服务器建立多个TCP连接来加快资源获取的速度，而在HTTP2不需要这么做。</li><li><strong>帧乱序传输</strong>：注意HTTP2的数据传输时双向的，这意味着请求和响应可以在同一个TCP连接中同时传输。，数据可以乱序传输，因为每个数据帧都会记录了自己属于哪个请求以及自己的顺序，只要在数据传输的终点根据帧数据的提供信息把帧拼接起来，即可获取一个完整的请求。这么做的好处是解决了HTTP1.x中的阻塞问题。</li><li><strong>并行传输</strong>：可以并行传输多个HTTP请求（多流）。在HTTP1.1时虽然有长连接和管道化，但长连接的同一时刻只有一个请求被发送，要实现并行请求，得多个TCP连接。</li></ul><h3 id="3-优先值"><a href="#3-优先值" class="headerlink" title="3.优先值"></a>3.优先值</h3><p>HTTP2中每个请求都可以携带一个 31bit 的优先值，0 表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。</p><h3 id="4-头部压缩"><a href="#4-头部压缩" class="headerlink" title="4.头部压缩"></a>4.头部压缩</h3><p>文章的简介中提到过HTTP1.x中的请求头部开销大，有很大的优化空间，HTTP2就是用压缩策略(HPACK)来进行优化。</p><p>下面这张截图，取自 Google 的性能专家 Ilya Grigorik 在 Velocity 2015 • SC 会议中分享的「<a href="http://velocityconf.com/devops-web-performance-2015/public/schedule/detail/42385">HTTP/2 is here, let’s optimize!</a>」，非常直观地描述了 HTTP/2 中头部压缩的原理：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://st.imququ.com/i/webp/static/uploads/2015/10/hpack-header-compression.png.webp" alt="hpack-header-compression" title="">                </div>                <div class="image-caption">hpack-header-compression</div>            </figure><p>通俗地讲：</p><ol><li><p>服务端和客户端在建立连接后共同维护一份静态字典(Static table)，字典中包含常见的头部名称，以及特别常见的头部名称与值的组合；</p><p>那么静态字典有什么用呢？</p><p>我们可以看到字典中每个键值对都有索引值，如果我们发送的HTTP请求的头部信息和静态字典中的某一项完全匹配，那么我们用索引值就能代表某个请求头部信息，这样就大大缩小了头部信息的大小。</p></li><li><p>维护一份相同的动态字典（Dynamic Table），可以动态地添加内容；</p><p>如果请求的某一个头部信息在静态字典中匹配不到，那么我们需要把这个头部信息放进动态字典中并更新字典，那么以后我们就能继续用索引值来表示这个头部信息。</p></li><li><p>字典中的数据支持哈夫曼编码。</p><p>简单介绍一下哈夫曼编码：</p><p>哈夫曼编码(Huffman Coding)是一种编码方式，以哈夫曼树—即最优二叉树，带权路径长度最小的二叉树，经常应用于数据压缩。在计算机信息处理中，“哈夫曼编码”是一种一致性编码法（又称”熵编码法”），用于数据的无损耗压缩。这一术语是指使用一张特殊的编码表将源字符（例如某文件中的一个符号）进行编码。这张编码表的特殊之处在于，它是根据每一个源字符出现的估算概率而建立起来的（出现概率高的字符使用较短的编码，反之出现概率低的则使用较长的编码，这便使编码之后的字符串的平均期望长度降低，从而达到无损压缩数据的目的）。这种方法是由David.A.Huffman发展起来的。例如，在英文中，e的出现概率很高，而z的出现概率则最低。当利用哈夫曼编码对一篇英文进行压缩时，e极有可能用一个位(bit)来表示，而z则可能花去 25个位（不是26）。用普通的表示方法时，每个英文字母均占用一个字节（byte），即8个位。二者相比，e使用了一般编码的1/8的长度，z则使用了 3倍多。倘若我们能实现对于英文中各个字母出现概率的较准确的估算，就可以大幅度提高无损压缩的比例。</p></li></ol><h3 id="5-服务端推送"><a href="#5-服务端推送" class="headerlink" title="5.服务端推送"></a>5.服务端推送</h3><p>当客户端向服务端请求一个HTML文件时，客户端很可能需要继续请求相关的CSS、JS文件。在HTTP2之前，客户端会在解析HTML时发现依赖的CSS、JS、图片等资源，然后向指定的地址来发送请求。</p><p>我们能从中发现问题：一是需要多轮HTTP请求，二是收到样式文件之前，网页都会显示一片空白，这个阶段一旦超过2秒，用户体验就会非常不好。</p><p>在HTTP2之前的解决方案：</p><p>一种解决办法就是把外部资源合并在网页文件里面，减少 HTTP 请求。比如，把样式表的内容写在<code>&lt;style&gt;</code>标签之中，把图片改成 Base64 编码的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs">Data URL</a>。</p><p>另一种方法就是资源的<a href="https://w3c.github.io/preload/">预加载</a>（preload）。网页预先告诉浏览器，立即下载某些资源。</p><p>这两种方法都有缺点。第一种方法虽然减少了 HTTP 请求，但是把不同类型的代码合并在一个文件里，违反了分工原则。第二种方法只是提前了下载时间，并没有减少 HTTP 请求。</p><p>HTTP2的服务端推送能解决这个问题。</p><h4 id="什么是服务端推送？"><a href="#什么是服务端推送？" class="headerlink" title="什么是服务端推送？"></a>什么是服务端推送？</h4><p>服务器推送（server push）指的是，还没有收到浏览器的请求，服务器就把各种资源推送给浏览器。</p><p>比如，浏览器只请求了<code>index.html</code>，但是服务器把<code>index.html</code>、<code>style.css</code>、<code>example.png</code>全部发送给浏览器。这样的话，只需要一轮 HTTP 通信，浏览器就得到了全部资源，提高了性能。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://image.fundebug.com/2019-03-06-6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="服务端推送的过程？"><a href="#服务端推送的过程？" class="headerlink" title="服务端推送的过程？"></a>服务端推送的过程？</h4><p>PUSH_PROMISE 101</p><p>所有服务器推送数据流都由 <code>PUSH_PROMISE</code> 帧发起，表明了服务器向客户端推送所述资源的意图，并且需要先于请求推送资源的响应数据传输。 这种传输顺序非常重要: 客户端需要了解服务器打算推送哪些资源，以免为这些资源创建重复请求。 满足此要求的最简单策略是先于父响应（即，<code>DATA</code> 帧）发送所有 <code>PUSH_PROMISE</code> 帧，其中包含所承诺资源的 HTTP 标头。</p><p>在客户端接收到 <code>PUSH_PROMISE</code> 帧后，它可以根据自身情况选择拒绝数据流（通过 <code>RST_STREAM</code> 帧）。 （例如，如果资源已经位于缓存中，便可能会发生这种情况。） 这是一个相对于 HTTP/1.x 的重要提升。 相比之下，使用资源内联（一种受欢迎的 HTTP/1.x“优化”）等同于“强制推送”: 客户端无法选择拒绝、取消或单独处理内联的资源。</p><p>使用 HTTP/2，客户端仍然完全掌控服务器推送的使用方式。 客户端可以限制并行推送的数据流数量；调整初始的流控制窗口以控制在数据流首次打开时推送的数据量；或完全停用服务器推送。 这些优先级在 HTTP/2 连接开始时通过 <code>SETTINGS</code> 帧传输，可能随时更新。</p><p>推送的每个资源都是一个数据流，与内嵌资源不同，客户端可以对推送的资源逐一复用、设定优先级和处理。 浏览器强制执行的唯一安全限制是，推送的资源必须符合原点相同这一政策: 服务器对所提供内容必须具有权威性。</p><p>以上这段话其实说得不够深入。</p><p>Server push 的原理很简单，本质上就是<strong>先替你请求再告诉你</strong>。</p><p>假设服务端接收到客户端对 HTML 文件的请求，决定用 server push 推送一个样式表文件。那么，服务端会构造一个请求，包括请求方法和请求头，填充到一个 <a href="https://link.zhihu.com/?target=https://http2.github.io/http2-spec/index.html%23PUSH_PROMISE">PUSH_PROMISE</a> 帧里发送给客户端，来告知客户端它已经代劳发了这个请求。客户端可以根据 PUSH_PROMISE 帧里提供的 Promised Stream Id 来读推过去的响应。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic2.zhimg.com/80/v2-3b337b0e6f342b6fd0a31b8fe18eee15_1440w.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>当客户端收到这个 PUSH_PROMISE 帧的时候，它就知道服务端将要推送一个样式表文件回来。如果此时客户端需要请求这个样式表文件，即便服务端还没推完，它也不会往服务端发送对样式表文件的请求。</p><p>这里需要注意的是避免<strong>竞争</strong>。在上面的例子中，必须先发送 PUSH_PROMISE，再发送 HTML 的内容。这是因为 HTML 中存在对样式表文件的引用，一旦客户端发现了这个引用却还没收到 PUSH_PROMISE，它就会发起请求。这会引起 PUSH_PROMISE 和对样式表文件的请求之间的竞争，从而 server push 有一定的几率失败。</p><p>另一种竞争是不可避免的。如果客户端认为它不需要某个即将被推过来的资源（比如这个资源还在缓存的有效期内），那么它会 reset 掉相应的流。但是即便如此，服务端在收到 RST_STREAM 帧的时候，很有可能已经推了一部分数据了。这种服务端开始推送数据和 RST_STREAM 帧之间的竞争是难以避免的（这是 feature 而不是 BUG）。</p><h4 id="服务端推送的实现"><a href="#服务端推送的实现" class="headerlink" title="服务端推送的实现"></a>服务端推送的实现</h4><p><strong>标识依赖资源</strong></p><p>W3C候选推荐标准（<a href="https://www.w3.org/TR/preload/%EF%BC%89%E5%BB%BA%E8%AE%AE%E4%BA%86%E4%BE%9D%E8%B5%96%E8%B5%84%E6%BA%90%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%81%9A%E6%B3%95%EF%BC%9A%E6%96%87%E4%BB%B6%E5%86%85">https://www.w3.org/TR/preload/）建议了依赖资源的两种做法：文件内</a><link>标签和HTTP头部携带, 表示该资源后续会被使用, 可以预请求, 关键字preload修饰这个资源, 写法如下：</p><p><strong>a) 静态Link标签法:</strong></p><link rel="preload" href="push.css" as="style"><p><strong>b) HTTP头表示法：</strong></p><p>Link: &lt;push.css&gt;; rel=preload; as=style</p><p>其中rel表明了资源&lt;/push.css&gt;是预加载的，as表明了资源的文件类型。另外，link还可以用nopush修饰，表示浏览器可能已经有该资源缓存，指示有推送能力的服务端不主动推送资源，只有当浏览器先检查到没有缓存，才去指示服务端推送资源，nopush格式写成：</p><p>Link: &lt;/app/script.js&gt;; rel=preload; as=script;nopush。</p><p>总结一下：</p><p>客户端向服务端请求一个html文件，服务端进行推送，并把相关的资源(或者资源链接)推送给客户端(通过HTTP请求头的LINK或者HTML中的preload)。</p><p>客户端知道了服务端要推送相关资源，可以选择接收和不接收。如果客户端不接收，可以通过 RST_STREAM 帧告诉服务端，服务端会停止推送。</p><p>服务端为了避免重复推送，可以在请求头的LINK中加上nopush，服务端看到nopush后会检查自己是否有相关资源，然后选择要不要服务端推送。</p><p>参考文章：</p><p>1.<a href="https://imququ.com/post/header-compression-in-http2.html">HTTP/2 头部压缩技术介绍</a></p><p>2.<a href="https://blog.fundebug.com/2019/03/07/understand-http2-and-http3/">一文读懂 HTTP/2 及 HTTP/3 特性</a></p><p>3.[哈夫曼编码的作用</p><p>4.<a href="http://www.duorenwei.com/news/1369.html">HTTP/2之服务器推送(Server Push)最佳实践</a></p><p>5.<a href="https://developers.google.com/web/fundamentals/performance/http2?hl=zh-cn#push_promise_101">HTTP/2 简介</a></p>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;文章摘要：了解HTTP2的新特性&quot;&gt;&lt;a href=&quot;#文章摘要：了解HTTP2的新特性&quot; class=&quot;headerlink&quot; title=&quot;文章摘要：了解HTTP2的新特性&quot;&gt;&lt;/a&gt;文章摘要：了解HTTP2的新特性&lt;/h5&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://jrr997.github.io/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="HTTP" scheme="https://jrr997.github.io/blog/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP1.1特性</title>
    <link href="https://jrr997.github.io/blog/2021/03/10/HTTP1-1/"/>
    <id>https://jrr997.github.io/blog/2021/03/10/HTTP1-1/</id>
    <published>2021-03-10T11:50:19.000Z</published>
    <updated>2021-03-12T06:24:05.701Z</updated>
    
    <content type="html"><![CDATA[<h5 id="文章摘要：了解HTTP1-1的新特性"><a href="#文章摘要：了解HTTP1-1的新特性" class="headerlink" title="文章摘要：了解HTTP1.1的新特性"></a>文章摘要：了解HTTP1.1的新特性<a id="more"></a></h5><h1 id="HTTP1-1新特性"><a href="#HTTP1-1新特性" class="headerlink" title="HTTP1.1新特性"></a>HTTP1.1新特性</h1><h2 id="HTTP1-1特性："><a href="#HTTP1-1特性：" class="headerlink" title="HTTP1.1特性："></a>HTTP1.1特性：</h2><ul><li>默认长连接：新增Connection字段，可以设置keep-alive值保持连接不断开。</li><li>管道化：可以在发送一个请求后继续发送第二个请求，不必等第一个请求的响应。</li><li>缓存处理：新增字段cache-control，ETag。</li></ul><p>缓存：</p><ul><li><p>强缓存：expires(HTTP1.0)、cache-control(HTTP1.1)</p><p>在cache-control中，</p><p>有max-age表示过期时间是时间戳。</p><p>no-store表示不使用缓存，</p><p>no-cache表示不使用协商缓存</p></li><li><p>协商缓存：Last-Modified(HTTP1.0)和If-modified-since，Etag(HTTP1.1)和If-none-match。</p></li></ul><p>注意：cache-control优先级比expires高。</p>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;文章摘要：了解HTTP1-1的新特性&quot;&gt;&lt;a href=&quot;#文章摘要：了解HTTP1-1的新特性&quot; class=&quot;headerlink&quot; title=&quot;文章摘要：了解HTTP1.1的新特性&quot;&gt;&lt;/a&gt;文章摘要：了解HTTP1.1的新特性&lt;/h5&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://jrr997.github.io/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="HTTP" scheme="https://jrr997.github.io/blog/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码阅读(4)之AST</title>
    <link href="https://jrr997.github.io/blog/2021/02/27/vue-src-readding-4/"/>
    <id>https://jrr997.github.io/blog/2021/02/27/vue-src-readding-4/</id>
    <published>2021-02-27T14:05:49.000Z</published>
    <updated>2021-03-12T06:20:15.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>编译的过程就是把模板变成<code>render</code>函数.</p><p>Vue.js 提供了 2 个版本，一个是 Runtime + Compiler 的，一个是 Runtime only 的，前者是包含编译代码的，可以把编译过程放在运行时做，后者是不包含编译代码的，需要借助 webpack 的 <code>vue-loader</code> 事先把模板编译成 <code>render</code>函数。<a id="more"></a></p><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>vue的编译过程主要分为三步：</p><ul><li>解析模板字符串生成AST</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ast = parse(template.trim(), options)</span><br></pre></td></tr></tbody></table></figure><ul><li>优化语法树</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimize(ast, options)</span><br></pre></td></tr></tbody></table></figure><ul><li>生成代码</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> code = generate(ast, options)</span><br></pre></td></tr></tbody></table></figure><h2 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h2><h3 id="什么是AST"><a href="#什么是AST" class="headerlink" title="什么是AST"></a>什么是AST</h3><p>AST是抽象语法树，它具体是这样的：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">:class</span>=<span class="string">"bindCls"</span> <span class="attr">class</span>=<span class="string">"list"</span> <span class="attr">v-if</span>=<span class="string">"isShow"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in data"</span> @<span class="attr">click</span>=<span class="string">"clickItem(index)"</span>&gt;</span>{{item}}:{{index}}<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>经过 <code>parse</code> 过程后，生成的 AST 如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">ast = {</span><br><span class="line">  <span class="string">'type'</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">'tag'</span>: <span class="string">'ul'</span>,</span><br><span class="line">  <span class="string">'attrsList'</span>: [],</span><br><span class="line">  <span class="string">'attrsMap'</span>: {</span><br><span class="line">    <span class="string">':class'</span>: <span class="string">'bindCls'</span>,</span><br><span class="line">    <span class="string">'class'</span>: <span class="string">'list'</span>,</span><br><span class="line">    <span class="string">'v-if'</span>: <span class="string">'isShow'</span></span><br><span class="line">  },</span><br><span class="line">  <span class="string">'if'</span>: <span class="string">'isShow'</span>,</span><br><span class="line">  <span class="string">'ifConditions'</span>: [{</span><br><span class="line">    <span class="string">'exp'</span>: <span class="string">'isShow'</span>,</span><br><span class="line">    <span class="string">'block'</span>: <span class="comment">// ul ast element</span></span><br><span class="line">  }],</span><br><span class="line">  <span class="string">'parent'</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="string">'plain'</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">'staticClass'</span>: <span class="string">'list'</span>,</span><br><span class="line">  <span class="string">'classBinding'</span>: <span class="string">'bindCls'</span>,</span><br><span class="line">  <span class="string">'children'</span>: [{</span><br><span class="line">    <span class="string">'type'</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">'tag'</span>: <span class="string">'li'</span>,</span><br><span class="line">    <span class="string">'attrsList'</span>: [{</span><br><span class="line">      <span class="string">'name'</span>: <span class="string">'@click'</span>,</span><br><span class="line">      <span class="string">'value'</span>: <span class="string">'clickItem(index)'</span></span><br><span class="line">    }],</span><br><span class="line">    <span class="string">'attrsMap'</span>: {</span><br><span class="line">      <span class="string">'@click'</span>: <span class="string">'clickItem(index)'</span>,</span><br><span class="line">      <span class="string">'v-for'</span>: <span class="string">'(item,index) in data'</span></span><br><span class="line">     },</span><br><span class="line">    <span class="string">'parent'</span>: <span class="comment">// ul ast element</span></span><br><span class="line">    <span class="string">'plain'</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">'events'</span>: {</span><br><span class="line">      <span class="string">'click'</span>: {</span><br><span class="line">        <span class="string">'value'</span>: <span class="string">'clickItem(index)'</span></span><br><span class="line">      }</span><br><span class="line">    },</span><br><span class="line">    <span class="string">'hasBindings'</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">'for'</span>: <span class="string">'data'</span>,</span><br><span class="line">    <span class="string">'alias'</span>: <span class="string">'item'</span>,</span><br><span class="line">    <span class="string">'iterator1'</span>: <span class="string">'index'</span>,</span><br><span class="line">    <span class="string">'children'</span>: [</span><br><span class="line">      <span class="string">'type'</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="string">'expression'</span>: <span class="string">'_s(item)+":"+_s(index)'</span></span><br><span class="line">      <span class="string">'text'</span>: <span class="string">'{{item}}:{{index}}'</span>,</span><br><span class="line">      <span class="string">'tokens'</span>: [</span><br><span class="line">        {<span class="string">'@binding'</span>:<span class="string">'item'</span>},</span><br><span class="line">        <span class="string">':'</span>,</span><br><span class="line">        {<span class="string">'@binding'</span>:<span class="string">'index'</span>}</span><br><span class="line">      ]</span><br><span class="line">    ]</span><br><span class="line">  }]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="如何生成AST？"><a href="#如何生成AST？" class="headerlink" title="如何生成AST？"></a>如何生成AST？</h3><p>主要通过正则匹配来解析模板，流程图如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ustbhuangyi.github.io/vue-analysis/assets/parse.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2019/5/26/16af44ef4c97f6ef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="optimize（优化AST）"><a href="#optimize（优化AST）" class="headerlink" title="optimize（优化AST）"></a>optimize（优化AST）</h2><h3 id="为什么要优化AST？"><a href="#为什么要优化AST？" class="headerlink" title="为什么要优化AST？"></a>为什么要优化AST？</h3><p>因为Vue是数据驱动、响应式的，但是我们的模板并不是所有数据都是响应式的，也有很多数据是首次渲染后就永远不会变化的，那么这部分数据生成的 DOM 也不会变化，我们可以在 <code>patch</code> 的过程跳过对他们的比对。</p><h3 id="如何进行优化？"><a href="#如何进行优化？" class="headerlink" title="如何进行优化？"></a>如何进行优化？</h3><p><code>optimize</code> 的过程，就是深度遍历这个 AST 树，去检测它的每一颗子树是不是静态节点，如果是静态节点则它们生成 DOM 永远不需要改变，这对运行时对模板的更新起到极大的优化作用。</p><p>我们通过 <code>optimize</code> 我们把整个 AST 树中的每一个 AST 元素节点标记了 <code>static</code> 和 <code>staticRoot</code>，它会影响我们接下来执行代码生成的过程。</p><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><p>这里就是把经过优化的AST转化为render函数。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介：&quot;&gt;&lt;a href=&quot;#简介：&quot; class=&quot;headerlink&quot; title=&quot;简介：&quot;&gt;&lt;/a&gt;简介：&lt;/h2&gt;&lt;p&gt;编译的过程就是把模板变成&lt;code&gt;render&lt;/code&gt;函数.&lt;/p&gt;
&lt;p&gt;Vue.js 提供了 2 个版本，一个是 Runtime + Compiler 的，一个是 Runtime only 的，前者是包含编译代码的，可以把编译过程放在运行时做，后者是不包含编译代码的，需要借助 webpack 的 &lt;code&gt;vue-loader&lt;/code&gt; 事先把模板编译成 &lt;code&gt;render&lt;/code&gt;函数。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://jrr997.github.io/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Vue" scheme="https://jrr997.github.io/blog/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码阅读(3)之响应式原理</title>
    <link href="https://jrr997.github.io/blog/2021/02/22/vue-src-readding-3/"/>
    <id>https://jrr997.github.io/blog/2021/02/22/vue-src-readding-3/</id>
    <published>2021-02-22T11:25:28.000Z</published>
    <updated>2021-02-22T11:35:00.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇文章属于新手向，着重点在理解Vue响应式系统中的Observer、Dep、Watcher,这是理解响应式源码的关键。因此这篇文章不会在分析源码上花很多功夫。<a id="more"></a></p><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h2><p>我们都知道Vue的响应式原理是通过<code>Object.defineProperty</code>修改get和set方法来实现的，当我们访问一个变量时就会执行get方法，当我们修改一个变量时会执行set方法。为了实现响应式，我们可以在get方法中收集依赖，这样就能知道哪些数据依赖当前数据。当数据发生变化时，set方法通知依赖者(watcher)进行数据更新。</p><p>Observer就是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新。</p><p>在介绍observer前，先要了解initState()的过程。</p><h2 id="initState"><a href="#initState" class="headerlink" title="initState"></a>initState</h2><p>在new Vue时，会执行<code>_init</code>方法进行初始化，当中有一个<code>initState</code>方法，主要是对 <code>props</code>、<code>methods</code>、<code>data</code>、<code>computed</code> 和 <code>wathcer</code> 等属性做了初始化操作。这里我们重点分析 <code>props</code> 和 <code>data</code>。</p><ul><li>initProps<ul><li>遍历所有props，调用 <code>defineReactive</code> 方法把每个 <code>prop</code> 对应的值变成响应式。</li><li>通过 <code>proxy</code> 把 <code>vm._props.xxx</code> 的访问代理到 <code>vm.xxx</code> 上。</li></ul></li><li>initData<ul><li>调用 <code>observe</code> 方法观测整个 <code>data</code> 的变化，把 <code>data</code> 也变成响应式。</li><li>通过 <code>proxy</code> 把每一个值 <code>vm._data.xxx</code> 都代理到 <code>vm.xxx</code> 上。</li></ul></li></ul><p>这里涉及三个陌生的方法：<code>proxy</code> 、<code>observe</code>和<code>defineReactive</code>，下面分别介绍。</p><ul><li><p><code>proxy</code>：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">proxy</span> (<span class="params">target: <span class="built_in">Object</span>, sourceKey: string, key: string</span>) </span>{</span><br><span class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[sourceKey][key]</span><br><span class="line">  }</span><br><span class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span> (<span class="params">val</span>) </span>{</span><br><span class="line">    <span class="built_in">this</span>[sourceKey][key] = val</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>简单来讲，创建一个<code>vm.xxx</code>属性，当我们访问和修改这个属性时，其实是在访问和修改<code>vm._data.xxx</code>，这是就是为什么我们能够通过this来访问到data和props。</p></li><li><p><code>observe</code>：</p></li></ul><p><code>observe</code> 方法的作用就是给非 VNode 的对象类型数据添加一个 <code>Observer</code>，如果已经添加过则直接返回，否则在满足一定条件下去实例化一个 <code>Observer</code> 对象实例，Observer等一会介绍。</p><ul><li><code>defineReactive</code>：</li></ul><p><code>defineReactive</code> 的功能就是定义一个响应式对象，给对象动态添加 getter 和 setter，它的定义在 <code>src/core/observer/index.js</code> 中。</p><p>步骤：</p><ol><li>new Dep()。 </li><li>拿到 <code>obj</code> 的属性描述符，然后对子对象递归调用 <code>observe</code> 方法。</li></ol><h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><p>Observer步骤：</p><ol><li>new Dep()。</li><li>执行 <code>def</code> 函数把自身实例添加到数据对象 <code>value</code> 的 <code>__ob__</code> 属性上。</li><li>对数据<code>value</code>进行判断，如果是数组则遍历调用<code>observe</code>方法，如果是对象则调用 <code>walk</code> 方法，而 <code>walk</code> 方法是遍历对象的 key 调用 <code>defineReactive</code> 方法，那么我们来看一下这个方法是做什么的。</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observer class that is attached to each observed</span></span><br><span class="line"><span class="comment"> * object. Once attached, the observer converts the target</span></span><br><span class="line"><span class="comment"> * object's property keys into getter/setters that</span></span><br><span class="line"><span class="comment"> * collect dependencies and dispatch updates.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>{</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: number; <span class="comment">// number of vms that has this object as root $data</span></span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value: any</span>) {</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="built_in">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">    def(value, <span class="string">'__ob__'</span>, <span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) {</span><br><span class="line">      <span class="keyword">const</span> augment = hasProto</span><br><span class="line">        ? protoAugment</span><br><span class="line">        : copyAugment</span><br><span class="line">      augment(value, arrayMethods, arrayKeys)</span><br><span class="line">      <span class="built_in">this</span>.observeArray(value)</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="built_in">this</span>.walk(value)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Walk through each property and convert them into</span></span><br><span class="line"><span class="comment">   * getter/setters. This method should only be called when</span></span><br><span class="line"><span class="comment">   * value type is Object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  walk (obj: <span class="built_in">Object</span>) {</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) {</span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Observe a list of Array items.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) {</span><br><span class="line">      observe(items[i])</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h2><h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>{</span><br><span class="line">  <span class="keyword">static</span> target: ?Watcher; <span class="comment">// 静态属性target(Watcher类型)</span></span><br><span class="line">  id: number;</span><br><span class="line">  subs: <span class="built_in">Array</span>&lt;Watcher&gt;; <span class="comment">// 一个（Watcher类型）数组</span></span><br><span class="line">  </span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) {</span><br><span class="line">    <span class="built_in">this</span>.id = uid++</span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  addSub (sub: Watcher) {</span><br><span class="line">    <span class="comment">/* 为后续数据变化时候能通知到哪些 subs 做准备 */</span></span><br><span class="line">    <span class="built_in">this</span>.subs.push(sub)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  removeSub (sub: Watcher) {</span><br><span class="line">    remove(<span class="built_in">this</span>.subs, sub)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  depend () {</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) {</span><br><span class="line">      Dep.target.addDep(<span class="built_in">this</span>)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  notify () {</span><br><span class="line">    <span class="comment">/* 所有Watcher的实例对象 */</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="built_in">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) {</span><br><span class="line">      subs[i].update()</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>什么是依赖？</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>{{message}}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: {</span><br><span class="line">    text: <span class="string">'hello world'</span>,</span><br><span class="line">    message: <span class="string">'hello vue'</span>,</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch: {</span><br><span class="line">    message: <span class="function"><span class="keyword">function</span> (<span class="params">val, oldVal</span>) </span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'new: %s, old: %s'</span>, val, oldVal)</span><br><span class="line">    },</span><br><span class="line">}   </span><br></pre></td></tr></tbody></table></figure><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: {</span><br><span class="line">    <span class="function"><span class="title">messageT</span>(<span class="params"></span>)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.message + <span class="string">'!'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里可以看到，虽然data中有text和message，但只有message被使用了，因此只有message需要收集依赖。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2019/6/2/16b1857fd4532ff0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Dep如何收集依赖?</p><p>在getter中收集，当数据被访问时调用<code>dep.depend</code>。</p><p>什么是依赖？</p><p>其实就是<code>watcher</code>。</p><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>{</span><br><span class="line">  vm: Component;</span><br><span class="line">  deep: boolean;</span><br><span class="line">  sync: boolean;</span><br><span class="line">  deps: <span class="built_in">Array</span>&lt;Dep&gt;;</span><br><span class="line">  newDeps: <span class="built_in">Array</span>&lt;Dep&gt;;</span><br><span class="line">  depIds: SimpleSet;</span><br><span class="line">  newDepIds: SimpleSet;</span><br><span class="line">  before: ?<span class="built_in">Function</span>;</span><br><span class="line">  getter: <span class="built_in">Function</span>;</span><br><span class="line">  value: any;</span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">    vm: Component,</span></span><br><span class="line"><span class="params">    expOrFn: string | <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">    cb: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">    options?: ?<span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">    isRenderWatcher?: boolean</span></span><br><span class="line"><span class="params">  </span>) {</span><br><span class="line">    <span class="built_in">this</span>.vm = vm</span><br><span class="line">    vm._watchers.push(<span class="built_in">this</span>)</span><br><span class="line">    <span class="comment">/* 监听器的options */</span></span><br><span class="line">    <span class="keyword">if</span> (options) {</span><br><span class="line">      <span class="built_in">this</span>.deep = !!options.deep <span class="comment">// 深度监听</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="built_in">this</span>.sync = !!options.sync <span class="comment">// 在当前 Tick 中同步执行 watcher 的回调函数，否则响应式数据发生变化之后，watcher回调会在nextTick后执行；</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/* Watcher实例持有Dep的实例的数组 */</span></span><br><span class="line">    <span class="built_in">this</span>.deps = [] <span class="comment">// 老的Dep集合</span></span><br><span class="line">    <span class="built_in">this</span>.newDeps = [] <span class="comment">// 触发更新生成的新的Dep集合</span></span><br><span class="line">    <span class="built_in">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="built_in">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"></span><br><span class="line">  get () {</span><br><span class="line">    <span class="comment">/* 收集Watcher实例,也就是Dep.target */</span></span><br><span class="line">    pushTarget(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="built_in">this</span>.vm</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">/* this.getter对应就是我们上篇讲到的vm._update(vm._render(), hydrating),_update会生成VNode,在这个过程中会访</span></span><br><span class="line"><span class="comment">      问vm上的data，这时候就触发了数据对象的getter，defineReactive中可以发现每个getter都持有一个dep,</span></span><br><span class="line"><span class="comment">      因此在触发getter的时候会触发Dep的depend方法，也就触发了Watcher的addDep方法 */</span></span><br><span class="line">      value = <span class="built_in">this</span>.getter.call(vm, vm)</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">      <span class="comment">/* 把 Dep.target 恢复成上一个状态，因为当前 vm 的数据依赖收集已经完成，那么对应的渲染Dep.target 也需要改变 */</span></span><br><span class="line">      popTarget()</span><br><span class="line">      <span class="built_in">this</span>.cleanupDeps()</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  addDep (dep: Dep) {</span><br><span class="line">    <span class="keyword">const</span> id = dep.id</span><br><span class="line">    <span class="comment">/* 保证同一数据不会被添加多次 */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.newDepIds.has(id)) {</span><br><span class="line">      <span class="built_in">this</span>.newDepIds.add(id)</span><br><span class="line">      <span class="built_in">this</span>.newDeps.push(dep)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.depIds.has(id)) {</span><br><span class="line">        <span class="comment">/* 把当前的 watcher 订阅到这个数据持有的 dep 的 subs, 目的是为后续数据变化时候能通知到哪些 subs 做准备 */</span></span><br><span class="line">        dep.addSub(<span class="built_in">this</span>)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p> <code>watcher</code>中有两个方法:</p><ol><li><code>addDep</code>:看看自己依赖谁，然后告诉被依赖者，让自己进入被依赖者的<code>sub</code>名单。这样当被依赖者发生改变时就通知自己更新。</li><li><code>update</code>:当自己需要更新时调用，这个方法会在数据更新后渲染到页面上，并且调用<code>update</code>这个声明周期函数。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回顾一下，<code>Vue</code>响应式原理的核心就是<code>Observer</code>、<code>Dep</code>、<code>Watcher</code>。</p><p><code>Observer</code>中进行响应式的绑定，在数据被读的时候，触发<code>get</code>方法，执行<code>Dep</code>来收集依赖，也就是收集<code>Watcher</code>。</p><p>在数据被改的时候，触发<code>set</code>方法，通过对应的所有依赖(<code>Watcher</code>)，去执行更新。比如<code>watch</code>和<code>computed</code>就执行开发者自定义的回调方法。</p><p>本文参考了<a href="https://juejin.cn/post/6844903858850758670#heading-1%E3%80%82">https://juejin.cn/post/6844903858850758670#heading-1。</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本篇文章属于新手向，着重点在理解Vue响应式系统中的Observer、Dep、Watcher,这是理解响应式源码的关键。因此这篇文章不会在分析源码上花很多功夫。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://jrr997.github.io/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Vue" scheme="https://jrr997.github.io/blog/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码阅读(2)之组件化</title>
    <link href="https://jrr997.github.io/blog/2021/02/21/Vue-src-readding-2/"/>
    <id>https://jrr997.github.io/blog/2021/02/21/Vue-src-readding-2/</id>
    <published>2021-02-21T13:28:51.000Z</published>
    <updated>2021-02-21T13:33:02.563Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>组件化是Vue的一个核心思想。所谓组件化，就是把页面拆分成多个组件 (component)，每个组件依赖的 CSS、JavaScript、模板、图片等资源放在一起开发和维护。组件是资源独立的，组件在系统内部可复用，组件和组件之间可以嵌套。<a id="more"></a></p><p>本文主要关注Vue如何创建组件。</p><h2 id="createComponent"><a href="#createComponent" class="headerlink" title="createComponent"></a>createComponent</h2><p>在上一篇文章中介绍过<code>vm._render</code>方法，作用是根据<code>render</code>函数生成VDOM，生成VDOM主要是由<code>vm_render</code>方法中的<code>createElement</code>中的<code>_createElement</code>方法实现的。</p><p><code>_createElement</code>中有一段逻辑是对参数 <code>tag</code> 的判断，如果是一个普通的 html 标签，如div，则会实例化一个普通 VNode 节点，否则通过 <code>createComponent</code> 方法创建一个组件 VNode。</p><p><code>createComponent</code>有三个核心步骤：</p><ol><li>构造子类构造函数</li><li>安装组件钩子函数</li><li>实例化 VNode</li></ol><p>下面我会分别介绍这三个步骤。</p><h3 id="构造子类构造函数"><a href="#构造子类构造函数" class="headerlink" title="构造子类构造函数"></a>构造子类构造函数</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> baseCtor = context.$options._base</span><br><span class="line"></span><br><span class="line"><span class="comment">// plain options object: turn it into a constructor</span></span><br><span class="line"><span class="keyword">if</span> (isObject(Ctor)) {</span><br><span class="line">  Ctor = baseCtor.extend(Ctor)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里 <code>baseCtor</code> 实际上就是 Vue，这个的定义是在最开始初始化 Vue 的阶段，在 <code>src/core/global-api/index.js</code> 中的 <code>initGlobalAPI</code> 函数有这么一段逻辑：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this is used to identify the "base" constructor to extend all plain-object</span></span><br><span class="line"><span class="comment">// components with in Weex's multi-instance scenarios.</span></span><br><span class="line">Vue.options._base = Vue</span><br></pre></td></tr></tbody></table></figure><p>我们可以注意到<code>context.$options._base</code>和<code>Vue.options._base</code>，前者是实例中取出<code>_base</code>，后者是构造函数中取出<code>_base</code>,那么为什么这两个地方都能取出<code>_base</code>呢？</p><p>实际上在 <code>src/core/instance/init.js</code> 里 Vue 原型上的 <code>_init</code> 函数中有这么一段逻辑：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vm.$options = mergeOptions(</span><br><span class="line">  resolveConstructorOptions(vm.constructor),</span><br><span class="line">  options || {},</span><br><span class="line">  vm</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>这样就把 Vue 上的一些 <code>option</code> 扩展到了 vm.$options 上，意思是vm(组件)的<code>options</code>中包含了Vue的<code>options</code>和用户传入的<code>options</code>。</p><p>回到<code>Ctor = baseCtor.extend(Ctor)</code>，这里Ctor是Vue的子类，继承了Vue的属性和方法，extend返回的是一个叫<code>Sub</code>的组件构造函数。当我们去实例化<code>Sub</code>时，就会执行 <code>this._init</code> 逻辑再次走到了 <code>Vue</code> 实例的初始化逻辑，这意味着组件的实例化和Vue的实例化相类似。</p><h3 id="安装钩子函数"><a href="#安装钩子函数" class="headerlink" title="安装钩子函数"></a>安装钩子函数</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// install component management hooks onto the placeholder node</span></span><br><span class="line">installComponentHooks(data)</span><br></pre></td></tr></tbody></table></figure><p>整个 <code>installComponentHooks</code> 的过程就是把 <code>componentVNodeHooks</code> 的钩子函数合并到 <code>data.hook</code> 中，在 VNode 执行 <code>patch</code> 的过程中执行相关的钩子函数。</p><p>简单地说是把生成VNode的方法都准备好，准备生成Vnode。</p><h3 id="实例化VNode"><a href="#实例化VNode" class="headerlink" title="# 实例化VNode"></a># 实例化VNode</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = Ctor.options.name || tag</span><br><span class="line"><span class="keyword">const</span> vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">  <span class="string">`vue-component-<span class="subst">${Ctor.cid}</span><span class="subst">${name ? <span class="string">`-<span class="subst">${name}</span>`</span> : <span class="string">''</span>}</span>`</span>,</span><br><span class="line">  data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</span><br><span class="line">  { Ctor, propsData, listeners, tag, children },</span><br><span class="line">  asyncFactory</span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> vnode</span><br></pre></td></tr></tbody></table></figure><p>最后一步非常简单，通过 <code>new VNode</code> 实例化一个 <code>vnode</code> 并返回。需要注意的是和普通元素节点的 <code>vnode</code> 不同，组件的 <code>vnode</code> 是没有 <code>children</code> 的，这点很关键，在之后的 <code>patch</code> 过程中我们会再提。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>创建一个组件经历了三个步骤：</p><ol><li>创建组件的构造函数</li><li>执行构造函数，准备好生成Vnode的相关方法。</li><li>生成Vnode。</li></ol><p>下图是组件创建过程的函数调用栈，通过调用栈我们也能更好地了解组件的创建过程。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="C:\Users\Jrrr\Desktop\Chrome" alt="组件创建过程" title="Download组件创建过程.png">                </div>                <div class="image-caption">Download组件创建过程.png</div>            </figure><p>由下往上看，跟着函数调用栈的顺序，可以看出整个过程是</p><ul><li><p>执行 new Vue，然后初始化 vm 实例，扩展原型方法</p></li><li><p>执行 mount 函数去解析编译 template 模板</p></li><li><p>执行 Watcher render 去生成 VNode tree</p></li><li><p>执行 update 中的 patch 去生成 DOM，如遇到组件</p></li><li><ul><li>初始化 Sub 构造器</li><li>执行 new Sub，初始化组件 vm 实例，扩展原型方法</li><li>执行 mount 函数解析编译组件模板，生成组件 VNode tree，最终返回组件 DOM</li><li>如再遇组件，则继续递归</li></ul></li></ul><p>可以看出 Vue 的组件生成顺序是由子到父的。</p><h2 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h2><p>既然有了VNode，下一步应该是调用<code>vm._update</code>来创建真实DOM，这个过程就是patch。</p><p>具体的过程就不细说，这里主要注意一个组件中可能又包含另外的组件。如果组件 <code>patch</code> 过程中又创建了子组件，那么DOM 的插入顺序是先子后父。</p><h2 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h2><h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h3><p>相当于在<code>Vue.options.components</code>注册了一个组件。因为局部组件都会通过<code>Vue.extend</code>创建一个<code>Sub</code>子类(前面介绍过)，而<code>Sub</code>会继承<code>Vue.options.components</code>，这里是通过<code>mergeOptions</code>实现的，前面也简单提到过。</p><p>到这里，局部组件就能通过<code>options</code>拿到全局组件。</p><h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><p>Vue.js 也同样支持局部注册，我们可以在一个组件内部使用 <code>components</code> 选项做组件的局部注册，例如：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">'./components/HelloWorld'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  components: {</span><br><span class="line">    HelloWorld</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其实理解了全局注册的过程，局部注册是非常简单的。在组件的 Vue 的实例化阶段有一个合并 <code>option</code> 的逻辑，之前我们也分析过，所以就把 <code>components</code> 合并到 <code>vm.$options.components</code> 上，这样我们就可以在 <code>resolveAsset</code> 的时候拿到这个组件的构造函数，并作为 <code>createComponent</code> 的钩子的参数。</p><p>注意，局部注册和全局注册不同的是，只有该类型的组件才可以访问局部注册的子组件，而全局注册是扩展到 <code>Vue.options</code> 下，所以在所有组件创建的过程中，都会从全局的 <code>Vue.options.components</code> 扩展到当前组件的 <code>vm.$options.components</code> 下，这就是全局注册的组件能被任意使用的原因。</p><h2 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h2><p>因为我在实战中并没有用过异步组件，这里就先留个坑，只是简单的了解一下异步组件的作用。</p><p>在我们平时的开发工作中，为了减少首屏代码体积，往往会把一些非首屏的组件设计成异步组件，按需加载。Vue 也原生支持了异步组件的能力，如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-example'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>{</span><br><span class="line">   <span class="comment">// 这个特殊的 require 语法告诉 webpack</span></span><br><span class="line">   <span class="comment">// 自动将编译后的代码分割成不同的块，</span></span><br><span class="line">   <span class="comment">// 这些块将通过 Ajax 请求自动下载。</span></span><br><span class="line">   <span class="built_in">require</span>([<span class="string">'./my-async-component'</span>], resolve)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>生命周期是一个很重要的知识点，我要单独开一篇文章来讲。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;组件化是Vue的一个核心思想。所谓组件化，就是把页面拆分成多个组件 (component)，每个组件依赖的 CSS、JavaScript、模板、图片等资源放在一起开发和维护。组件是资源独立的，组件在系统内部可复用，组件和组件之间可以嵌套。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://jrr997.github.io/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Vue" scheme="https://jrr997.github.io/blog/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码阅读(1)之数据驱动</title>
    <link href="https://jrr997.github.io/blog/2021/02/20/vue-src-readding-1/"/>
    <id>https://jrr997.github.io/blog/2021/02/20/vue-src-readding-1/</id>
    <published>2021-02-20T15:58:19.000Z</published>
    <updated>2021-02-21T13:33:10.589Z</updated>
    
    <content type="html"><![CDATA[<h5 id="文章摘要：通过阅读Vue源码来深入学习Vue，本文章主要介绍Vue的数据驱动部分源码。"><a href="#文章摘要：通过阅读Vue源码来深入学习Vue，本文章主要介绍Vue的数据驱动部分源码。" class="headerlink" title="文章摘要：通过阅读Vue源码来深入学习Vue，本文章主要介绍Vue的数据驱动部分源码。"></a>文章摘要：通过阅读Vue源码来深入学习Vue，本文章主要介绍Vue的数据驱动部分源码。<a id="more"></a></h5><p>作为学习者，这篇文章主要是参考<a href="https://ustbhuangyi.github.io/vue-analysis/v2/prepare/">https://ustbhuangyi.github.io/vue-analysis/v2/prepare/</a></p><h1 id="Vue源码阅读"><a href="#Vue源码阅读" class="headerlink" title="Vue源码阅读"></a>Vue源码阅读</h1><h2 id="一、vue的源码目录设计"><a href="#一、vue的源码目录设计" class="headerlink" title="一、vue的源码目录设计"></a>一、vue的源码目录设计</h2><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├── compiler        # 编译相关 </span><br><span class="line">├── core            # 核心代码 </span><br><span class="line">├── platforms       # 不同平台的支持</span><br><span class="line">├── server          # 服务端渲染</span><br><span class="line">├── sfc             # .vue 文件解析</span><br><span class="line">├── shared          # 共享代码</span><br></pre></td></tr></tbody></table></figure><h4 id="compiler"><a href="#compiler" class="headerlink" title="compiler"></a>compiler</h4><p>compiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。</p><h4 id="core"><a href="#core" class="headerlink" title="core"></a>core</h4><p>core 目录包含了 Vue.js 的核心代码，包括内置组件、全局 API 封装，Vue 实例化、观察者、虚拟 DOM、工具函数等等。</p><h4 id="Vue入口"><a href="#Vue入口" class="headerlink" title="Vue入口"></a>Vue入口</h4><p>Vue入口在</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/core/instance/index.js</span><br></pre></td></tr></tbody></table></figure><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { initMixin } <span class="keyword">from</span> <span class="string">'./init'</span></span><br><span class="line"><span class="keyword">import</span> { stateMixin } <span class="keyword">from</span> <span class="string">'./state'</span></span><br><span class="line"><span class="keyword">import</span> { renderMixin } <span class="keyword">from</span> <span class="string">'./render'</span></span><br><span class="line"><span class="keyword">import</span> { eventsMixin } <span class="keyword">from</span> <span class="string">'./events'</span></span><br><span class="line"><span class="keyword">import</span> { lifecycleMixin } <span class="keyword">from</span> <span class="string">'./lifecycle'</span></span><br><span class="line"><span class="keyword">import</span> { warn } <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    !(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">  ) {</span><br><span class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">this</span>._init(options)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">initMixin(Vue)</span><br><span class="line">stateMixin(Vue)</span><br><span class="line">eventsMixin(Vue)</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line">renderMixin(Vue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></tbody></table></figure><p>这里可以看出Vue是一个构造函数。我们可以看到Vue被传入很多<code>xxxMixin</code> 函数中，这些函数的作用是给Vue.prototype扩展方法。</p><p><code>initGlobalAPI</code></p><p>Vue.js 在整个初始化过程中，除了给它的原型 prototype 上扩展方法，还会给 <code>Vue</code> 这个对象本身扩展全局的静态方法，它的定义在 <code>src/core/global-api/index.js</code> 中，全局方法包括set、delete、nextTick等。</p><h2 id="二、数据驱动"><a href="#二、数据驱动" class="headerlink" title="二、数据驱动"></a>二、数据驱动</h2><p>Vue.js 一个核心思想是数据驱动。数据驱动是指数据驱动视图的生成，我们只用修改数据，视图就会发生相应的修改，免去操作DOM来修改视图的步骤。</p><h4 id="new-Vue-发生了什么？"><a href="#new-Vue-发生了什么？" class="headerlink" title="new Vue 发生了什么？"></a>new Vue 发生了什么？</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    !(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">  ) {</span><br><span class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">this</span>._init(options)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从这里可见，new Vue后执行了this._init方法，并传入了options，而this_init方法主要做了这些事情：合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher 等等。下面是this._init的部分代码。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) {</span><br><span class="line">    initProxy(vm)</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    vm._renderProxy = vm</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// expose real self</span></span><br><span class="line">  vm._self = vm</span><br><span class="line">  initLifecycle(vm)</span><br><span class="line">  initEvents(vm)</span><br><span class="line">  initRender(vm)</span><br><span class="line">  callHook(vm, <span class="string">'beforeCreate'</span>)</span><br><span class="line">  initInjections(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">  initState(vm)</span><br><span class="line">  initProvide(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">  callHook(vm, <span class="string">'created'</span>)</span><br></pre></td></tr></tbody></table></figure><p>在beforeCreate前，Vue已经初始化了生命周期、时间和渲染，在beforeCreate和created之间有一个initState方法，initState主要是初始化data、props等属性。意思是beforeCreate不能拿到data、props、methods、computed等，要在created中拿。</p><h4 id="Vue实例的挂载"><a href="#Vue实例的挂载" class="headerlink" title="Vue实例的挂载"></a>Vue实例的挂载</h4><p><code>compiler</code> 版本的 <code>$mount</code> 实现非常有意思，先来看一下 <code>src/platform/web/entry-runtime-with-compiler.js</code> 文件中定义：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount</span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>{</span><br><span class="line">  el = el &amp;&amp; query(el)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) {</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = <span class="built_in">this</span>.$options</span><br><span class="line">  <span class="comment">// resolve template/el and convert to render function</span></span><br><span class="line">  <span class="keyword">if</span> (!options.render) {</span><br><span class="line">    <span class="keyword">let</span> template = options.template</span><br><span class="line">    <span class="keyword">if</span> (template) {</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">'string'</span>) {</span><br><span class="line">        <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">'#'</span>) {</span><br><span class="line">          template = idToTemplate(template)</span><br><span class="line">          <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">          <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !template) {</span><br><span class="line">            warn(</span><br><span class="line">              <span class="string">`Template element not found or is empty: <span class="subst">${options.template}</span>`</span>,</span><br><span class="line">              <span class="built_in">this</span></span><br><span class="line">            )</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) {</span><br><span class="line">        template = template.innerHTML</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) {</span><br><span class="line">          warn(<span class="string">'invalid template option:'</span> + template, <span class="built_in">this</span>)</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">      }</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (el) {</span><br><span class="line">      template = getOuterHTML(el)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (template) {</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) {</span><br><span class="line">        mark(<span class="string">'compile'</span>)</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> { render, staticRenderFns } = compileToFunctions(template, {</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        shouldDecodeNewlinesForHref,</span><br><span class="line">        delimiters: options.delimiters,</span><br><span class="line">        comments: options.comments</span><br><span class="line">      }, <span class="built_in">this</span>)</span><br><span class="line">      options.render = render</span><br><span class="line">      options.staticRenderFns = staticRenderFns</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) {</span><br><span class="line">        mark(<span class="string">'compile end'</span>)</span><br><span class="line">        measure(<span class="string">`vue <span class="subst">${<span class="built_in">this</span>._name}</span> compile`</span>, <span class="string">'compile'</span>, <span class="string">'compile end'</span>)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> mount.call(<span class="built_in">this</span>, el, hydrating)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在<code>runtime-with-compiler</code>版本的代码中，<code>const mount = Vue.prototype.$mount</code>缓存了<code>runtime-only</code>的<code>$mount</code>，然后重写了<code>$mount</code>方法，这个重写的<code>$mount</code>方法主要做了两件事情：</p><p>第一步：Vue实例通过<code>$mount </code>来挂载vm，且<code>$mount </code>限制Vue实例不能挂载到<code>body</code>和<code>html</code>根节点上。</p><p>第二步：把<code>el</code>和<code>template</code>字符串转化为<code>render</code>方法。Vue 2.0 版本中，所有 Vue 的组件的渲染最终都需要 <code>render</code> 方法。</p><p>做完这两步之后，会执行之前缓存的<code>runtime-only</code>的<code>$mount</code>。这个挂载是真正的挂载。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public mount method</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>{</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="built_in">this</span>, el, hydrating)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>原先的<code>$mount</code> 方法实际上会去调用 <code>mountComponent</code> 方法，这个方法定义在 <code>src/core/instance/lifecycle.js</code> 文件中：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  el: ?Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>{</span><br><span class="line">  vm.$el = el</span><br><span class="line">  <span class="keyword">if</span> (!vm.$options.render) {</span><br><span class="line">    vm.$options.render = createEmptyVNode</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) {</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> ((vm.$options.template &amp;&amp; vm.$options.template.charAt(<span class="number">0</span>) !== <span class="string">'#'</span>) ||</span><br><span class="line">        vm.$options.el || el) {</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'You are using the runtime-only build of Vue where the template '</span> +</span><br><span class="line">          <span class="string">'compiler is not available. Either pre-compile the templates into '</span> +</span><br><span class="line">          <span class="string">'render functions, or use the compiler-included build.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'Failed to mount component: template or render function not defined.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  callHook(vm, <span class="string">'beforeMount'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) {</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="keyword">const</span> name = vm._name</span><br><span class="line">      <span class="keyword">const</span> id = vm._uid</span><br><span class="line">      <span class="keyword">const</span> startTag = <span class="string">`vue-perf-start:<span class="subst">${id}</span>`</span></span><br><span class="line">      <span class="keyword">const</span> endTag = <span class="string">`vue-perf-end:<span class="subst">${id}</span>`</span></span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      <span class="keyword">const</span> vnode = vm._render()</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">${name}</span> render`</span>, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      vm._update(vnode, hydrating)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">${name}</span> patch`</span>, startTag, endTag)</span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> {</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher's constructor</span></span><br><span class="line">  <span class="comment">// since the watcher's initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component's mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, {</span><br><span class="line">    before () {</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted) {</span><br><span class="line">        callHook(vm, <span class="string">'beforeUpdate'</span>)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) {</span><br><span class="line">    vm._isMounted = <span class="literal">true</span></span><br><span class="line">    callHook(vm, <span class="string">'mounted'</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这段代码说明了<code>mountComponent</code>做了两件事情：</p><ol><li>调用 <code>vm._render</code>生成了VNode，最终调用 <code>vm._update</code> 更新 DOM。</li><li>创建<code>Watcher</code>实例，而<code>watcher</code>做又做了两件事情：<ul><li>一个是初始化的时候会执行回调函数<code>callHook(vm, 'mounted')</code></li><li>二是当vm 实例中的监测的数据发生变化的时候执行回调函数```callHook(vm, ‘beforeUpdate’)``</li></ul></li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol><li>模板转化成render函数。</li><li><code>vm._render</code>生成了VNode。</li><li><code>callHook(vm, 'beforeUpdate')</code></li><li><code>vm._update</code> 更新 DOM。</li><li><code>callHook(vm, 'mounted')</code>或者<code>callHook(vm, 'beforeUpdate')</code></li></ol><h4 id="vm-render"><a href="#vm-render" class="headerlink" title="vm._render"></a>vm._render</h4><p>前面提到<code>vm._render</code>,这个方法的作用就是把<code>render</code>函数生成VNode，也就是虚拟DOM。</p><p>模板：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  {{ message }}</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>模板转为<code>render</code>函数：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">'div'</span>, {</span><br><span class="line">     attrs: {</span><br><span class="line">        id: <span class="string">'app'</span></span><br><span class="line">      },</span><br><span class="line">  }, <span class="built_in">this</span>.message)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>vm._render</code>方法传入<code>render</code>函数，生成VNode，这里的<code>$createElement</code>就是创建VNode的方法。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnode = render.call(vm._renderProxy, vm.$createElement)</span><br></pre></td></tr></tbody></table></figure><h4 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h4><p>首先必须知道为什么需要虚拟DOM？</p><p>因为浏览器的DOM是十分“昂贵”的，真实DOM十分庞大，每个真实DOM都有很多属性和方法。如果我们频繁地更新真实DOM，可能会出现性能问题，因此虚拟DOM就出现了。</p><p>那么什么是虚拟DOM？</p><p>虚拟DOM就是描述真实DOM的JS对象，与真实DOM对比起来，虚拟DOM是轻量的。它的核心定义无非就几个关键属性，标签名、数据、子节点、键值等。</p><p>虚拟DOM除了它的数据结构的定义，映射到真实的 DOM 实际上要经历 VNode 的 create、diff、patch 等过程。那么在 Vue.js 中，VNode 的 create 是通过之前提到的 <code>createElement</code> 方法创建的，我们接下来分析这部分的实现。</p><h4 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h4><p><code>createElement</code>做两件事情</p><ol><li><p>children 的规范化</p><p>由于 Virtual DOM 实际上是一个树状结构，每一个 VNode 可能会有若干个子节点，这些子节点应该也是 VNode 的类型。<code>_createElement</code> 接收的第 4 个参数 children 是任意类型的，因此我们需要把它们规范成 VNode 类型。</p><p>在大多数情况下children都是VNode类型的，但也有例外就是 <code>functional component</code> 函数式组件返回的是一个数组而不是一个根节点，所以会通过 <code>Array.prototype.concat</code> 方法把整个 <code>children</code> 数组打平，让它的深度只有一层。</p></li><li><p>VNode 的创建</p><ul><li><p>单节点就直接创建一个VNode。</p></li><li><p>如果是多个节点，会用数组表示，遍历创建VNode。</p></li><li><p>有时候数组中会嵌套数组，这时用递归。</p></li></ul></li></ol><p>经过这两个步骤就形成了一个 VNode Tree。</p><p>回到 <code>mountComponent</code> 函数的过程，我们已经知道 <code>vm._render</code> 是如何创建了一个 VNode，接下来就是要把这个 VNode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过 <code>vm._update</code> 完成的，接下来分析一下这个过程。</p><h4 id="vm-update"><a href="#vm-update" class="headerlink" title="vm._update"></a>vm._update</h4><p>Vue 的 <code>_update</code> 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候；由于我们这一章节只分析首次渲染部分，数据更新部分会在之后分析响应式原理的时候涉及。<code>_update</code> 方法的作用是把 VNode 渲染成真实的 DOM，它的定义在 <code>src/core/instance/lifecycle.js</code> 中。</p><p>首次渲染时vm._update的主要是调用一个<code>patch</code>方法</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// initial render</span><br><span class="line">vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)</span><br></pre></td></tr></tbody></table></figure><p>其中<code>patch</code>方法又有一个<code>creatElm</code>方法，作用是根据虚拟DOM创建真实DOM。</p><p>简单地讲，在首次渲染时，<code>_update</code>方法根据虚拟DOM数创建一个真实的DOM树然后插入到<code>vm.$el</code>上。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>那么至此我们从主线上把模板和数据如何渲染成最终的 DOM 的过程分析完毕了，我们可以通过下图更直观地看到从初始化 Vue 到最终渲染的整个过程。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ustbhuangyi.github.io/vue-analysis/assets/new-vue.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;文章摘要：通过阅读Vue源码来深入学习Vue，本文章主要介绍Vue的数据驱动部分源码。&quot;&gt;&lt;a href=&quot;#文章摘要：通过阅读Vue源码来深入学习Vue，本文章主要介绍Vue的数据驱动部分源码。&quot; class=&quot;headerlink&quot; title=&quot;文章摘要：通过阅读Vue源码来深入学习Vue，本文章主要介绍Vue的数据驱动部分源码。&quot;&gt;&lt;/a&gt;文章摘要：通过阅读Vue源码来深入学习Vue，本文章主要介绍Vue的数据驱动部分源码。&lt;/h5&gt;</summary>
    
    
    
    <category term="技术" scheme="https://jrr997.github.io/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Vue" scheme="https://jrr997.github.io/blog/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>这是一段很长很长很长很长很长很长很长很长很长很长的文字，用来测试一下标题</title>
    <link href="https://jrr997.github.io/blog/2021/02/18/test/"/>
    <id>https://jrr997.github.io/blog/2021/02/18/test/</id>
    <published>2021-02-17T16:26:21.000Z</published>
    <updated>2021-02-21T13:33:35.347Z</updated>
    
    <content type="html"><![CDATA[<h5 id="测试。"><a href="#测试。" class="headerlink" title="测试。"></a>测试。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;测试。&quot;&gt;&lt;a href=&quot;#测试。&quot; class=&quot;headerlink&quot; title=&quot;测试。&quot;&gt;&lt;/a&gt;测试。&lt;/h5&gt;</summary>
      
    
    
    
    <category term="日常" scheme="https://jrr997.github.io/blog/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="博客" scheme="https://jrr997.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>记录博客建站完成</title>
    <link href="https://jrr997.github.io/blog/2021/02/17/My-New-Post/"/>
    <id>https://jrr997.github.io/blog/2021/02/17/My-New-Post/</id>
    <published>2021-02-17T10:43:02.000Z</published>
    <updated>2021-02-21T13:34:09.514Z</updated>
    
    <content type="html"><![CDATA[<h5 id="文章摘要：记录博客建立完成及过程中遇到的坑"><a href="#文章摘要：记录博客建立完成及过程中遇到的坑" class="headerlink" title="文章摘要：记录博客建立完成及过程中遇到的坑"></a>文章摘要：记录博客建立完成及过程中遇到的坑<a id="more"></a></h5><h5 id="emsp-emsp-记录一下自己的博客顺利建成！"><a href="#emsp-emsp-记录一下自己的博客顺利建成！" class="headerlink" title="  记录一下自己的博客顺利建成！"></a>  记录一下自己的博客顺利建成！<br></h5><h5 id="emsp-emsp-本以为用HEXO建个博客挺容易的，结果还是踩了很多坑，不过最终还是顺利完成这个博客。"><a href="#emsp-emsp-本以为用HEXO建个博客挺容易的，结果还是踩了很多坑，不过最终还是顺利完成这个博客。" class="headerlink" title="  本以为用HEXO建个博客挺容易的，结果还是踩了很多坑，不过最终还是顺利完成这个博客。"></a>  本以为用HEXO建个博客挺容易的，结果还是踩了很多坑，不过最终还是顺利完成这个博客。<br></h5><h5 id="emsp-emsp-顺便记录一下这些坑吧。"><a href="#emsp-emsp-顺便记录一下这些坑吧。" class="headerlink" title="  顺便记录一下这些坑吧。"></a>  顺便记录一下这些坑吧。<br></h5><h5 id="第一个大坑"><a href="#第一个大坑" class="headerlink" title="第一个大坑:"></a>第一个大坑:<br></h5><h5 id="emsp-emsp-首先是博客主题的作者使用ejs来写的，按照主题的文档步骤来还是会报错，错误是-is-not-defined-in-XXX…，这里应该是这个博客最麻烦的地方，我并不知道这个-代表的是什么。"><a href="#emsp-emsp-首先是博客主题的作者使用ejs来写的，按照主题的文档步骤来还是会报错，错误是-is-not-defined-in-XXX…，这里应该是这个博客最麻烦的地方，我并不知道这个-代表的是什么。" class="headerlink" title="  首先是博客主题的作者使用ejs来写的，按照主题的文档步骤来还是会报错，错误是_ is not defined in XXX…，这里应该是这个博客最麻烦的地方，我并不知道这个_代表的是什么。"></a>  首先是博客主题的作者使用ejs来写的，按照主题的文档步骤来还是会报错，错误是_ is not defined in XXX…，这里应该是这个博客最麻烦的地方，我并不知道这个_代表的是什么。<br></h5><h5 id="emsp-emsp-后来据我观察，作者在三个地方都用到-XX方法，且三个地方只要执行了就会报错，其中作者用到了-template和-isArray-。"><a href="#emsp-emsp-后来据我观察，作者在三个地方都用到-XX方法，且三个地方只要执行了就会报错，其中作者用到了-template和-isArray-。" class="headerlink" title="  后来据我观察，作者在三个地方都用到 _.XX方法，且三个地方只要执行了就会报错，其中作者用到了_.template和_.isArray()。"></a>  后来据我观察，作者在三个地方都用到 _.XX方法，且三个地方只要执行了就会报错，其中作者用到了_.template和_.isArray()。<br></h5><h5 id="emsp-emsp-我盲猜作者是在ejs中使用了jquery，而这个-就是-的另外写法，但是我在往上并找不到相关的资料-VPN碰巧今晚过期了，因此可能没找详细。"><a href="#emsp-emsp-我盲猜作者是在ejs中使用了jquery，而这个-就是-的另外写法，但是我在往上并找不到相关的资料-VPN碰巧今晚过期了，因此可能没找详细。" class="headerlink" title="  我盲猜作者是在ejs中使用了jquery，而这个_就是$的另外写法，但是我在往上并找不到相关的资料(VPN碰巧今晚过期了，因此可能没找详细。)"></a>  我盲猜作者是在ejs中使用了jquery，而这个_就是$的另外写法，但是我在往上并找不到相关的资料(VPN碰巧今晚过期了，因此可能没找详细。)<br></h5><h5 id="emsp-emsp-我也不想在这个地方纠结了，于是只能将计就计，把有-的地方都删掉，或者用顺着思路其他方法代替，终于博客没报错并且能运行。"><a href="#emsp-emsp-我也不想在这个地方纠结了，于是只能将计就计，把有-的地方都删掉，或者用顺着思路其他方法代替，终于博客没报错并且能运行。" class="headerlink" title="  我也不想在这个地方纠结了，于是只能将计就计，把有_的地方都删掉，或者用顺着思路其他方法代替，终于博客没报错并且能运行。"></a>  我也不想在这个地方纠结了，于是只能将计就计，把有_的地方都删掉，或者用顺着思路其他方法代替，终于博客没报错并且能运行。<br><br></h5><h5 id="第二个大坑"><a href="#第二个大坑" class="headerlink" title="第二个大坑:"></a>第二个大坑:<br></h5><h5 id="emsp-emsp-点击阅读全文后，并没有显示内容，其中有部分原因是因为这个-，不过解决后还是没显示内容。但是审查元素发现其实内容是有的，这就让我怀疑是display-none，搞的鬼，但事实并不是这样。"><a href="#emsp-emsp-点击阅读全文后，并没有显示内容，其中有部分原因是因为这个-，不过解决后还是没显示内容。但是审查元素发现其实内容是有的，这就让我怀疑是display-none，搞的鬼，但事实并不是这样。" class="headerlink" title="  点击阅读全文后，并没有显示内容，其中有部分原因是因为这个__，不过解决后还是没显示内容。但是审查元素发现其实内容是有的，这就让我怀疑是display:none，搞的鬼，但事实并不是这样。"></a>  点击阅读全文后，并没有显示内容，其中有部分原因是因为这个__，不过解决后还是没显示内容。但是审查元素发现其实内容是有的，这就让我怀疑是display:none，搞的鬼，但事实并不是这样。<br></h5><h5 id="emsp-emsp-后来我改变浏览器窗口大小，当浏览器窗口宽度小于480px时居然显示出了内容，而且还是有动画的，然后我以为是动画的问题，于是往JS的方向找，结果被打脸了——找不到。"><a href="#emsp-emsp-后来我改变浏览器窗口大小，当浏览器窗口宽度小于480px时居然显示出了内容，而且还是有动画的，然后我以为是动画的问题，于是往JS的方向找，结果被打脸了——找不到。" class="headerlink" title="  后来我改变浏览器窗口大小，当浏览器窗口宽度小于480px时居然显示出了内容，而且还是有动画的，然后我以为是动画的问题，于是往JS的方向找，结果被打脸了——找不到。"></a>  后来我改变浏览器窗口大小，当浏览器窗口宽度小于480px时居然显示出了内容，而且还是有动画的，然后我以为是动画的问题，于是往JS的方向找，结果被打脸了——找不到。<br></h5><h5 id="emsp-emsp-那只剩下一个可能了——css的媒体查询。作者是通过opacity来隐藏页面的，我也不知道他为什么要隐藏，我把内容的opacity改成1就能一直显示了。"><a href="#emsp-emsp-那只剩下一个可能了——css的媒体查询。作者是通过opacity来隐藏页面的，我也不知道他为什么要隐藏，我把内容的opacity改成1就能一直显示了。" class="headerlink" title="  那只剩下一个可能了——css的媒体查询。作者是通过opacity来隐藏页面的，我也不知道他为什么要隐藏，我把内容的opacity改成1就能一直显示了。"></a>  那只剩下一个可能了——css的媒体查询。作者是通过opacity来隐藏页面的，我也不知道他为什么要隐藏，我把内容的opacity改成1就能一直显示了。</h5><h5 id="emsp-emsp-其实这个博客很多功能还不完善，后续我会接着更新。"><a href="#emsp-emsp-其实这个博客很多功能还不完善，后续我会接着更新。" class="headerlink" title="  其实这个博客很多功能还不完善，后续我会接着更新。"></a>  其实这个博客很多功能还不完善，后续我会接着更新。</h5><h5 id="emsp-emsp-最后祝贺自己成功搭建这个博客。"><a href="#emsp-emsp-最后祝贺自己成功搭建这个博客。" class="headerlink" title="  最后祝贺自己成功搭建这个博客。"></a>  最后祝贺自己成功搭建这个博客。</h5>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;文章摘要：记录博客建立完成及过程中遇到的坑&quot;&gt;&lt;a href=&quot;#文章摘要：记录博客建立完成及过程中遇到的坑&quot; class=&quot;headerlink&quot; title=&quot;文章摘要：记录博客建立完成及过程中遇到的坑&quot;&gt;&lt;/a&gt;文章摘要：记录博客建立完成及过程中遇到的坑&lt;/h5&gt;</summary>
    
    
    
    <category term="日常" scheme="https://jrr997.github.io/blog/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="博客" scheme="https://jrr997.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
