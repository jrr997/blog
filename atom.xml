<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  <subtitle>Blog</subtitle>
  <link href="https://jrr997.github.io/blog/atom.xml" rel="self"/>
  
  <link href="https://jrr997.github.io/blog/"/>
  <updated>2021-02-22T11:27:25.414Z</updated>
  <id>https://jrr997.github.io/blog/</id>
  
  <author>
    <name>Zack Chang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue源码阅读(2)之响应式原理</title>
    <link href="https://jrr997.github.io/blog/2021/02/22/vue-src-readding-3/"/>
    <id>https://jrr997.github.io/blog/2021/02/22/vue-src-readding-3/</id>
    <published>2021-02-22T11:25:28.000Z</published>
    <updated>2021-02-22T11:27:25.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇文章属于新手向，着重点在理解Vue响应式系统中的Observer、Dep、Watcher,这是理解响应式源码的关键。因此这篇文章不会在分析源码上花很多功夫。<a id="more"></a></p><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h2><p>我们都知道Vue的响应式原理是通过<code>Object.defineProperty</code>修改get和set方法来实现的，当我们访问一个变量时就会执行get方法，当我们修改一个变量时会执行set方法。为了实现响应式，我们可以在get方法中收集依赖，这样就能知道哪些数据依赖当前数据。当数据发生变化时，set方法通知依赖者(watcher)进行数据更新。</p><p>Observer就是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新。</p><p>在介绍observer前，先要了解initState()的过程。</p><h2 id="initState"><a href="#initState" class="headerlink" title="initState"></a>initState</h2><p>在new Vue时，会执行<code>_init</code>方法进行初始化，当中有一个<code>initState</code>方法，主要是对 <code>props</code>、<code>methods</code>、<code>data</code>、<code>computed</code> 和 <code>wathcer</code> 等属性做了初始化操作。这里我们重点分析 <code>props</code> 和 <code>data</code>。</p><ul><li>initProps<ul><li>遍历所有props，调用 <code>defineReactive</code> 方法把每个 <code>prop</code> 对应的值变成响应式。</li><li>通过 <code>proxy</code> 把 <code>vm._props.xxx</code> 的访问代理到 <code>vm.xxx</code> 上。</li></ul></li><li>initData<ul><li>调用 <code>observe</code> 方法观测整个 <code>data</code> 的变化，把 <code>data</code> 也变成响应式。</li><li>通过 <code>proxy</code> 把每一个值 <code>vm._data.xxx</code> 都代理到 <code>vm.xxx</code> 上。</li></ul></li></ul><p>这里涉及三个陌生的方法：<code>proxy</code> 、<code>observe</code>和<code>defineReactive</code>，下面分别介绍。</p><ul><li><p><code>proxy</code>：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">proxy</span> (<span class="params">target: <span class="built_in">Object</span>, sourceKey: string, key: string</span>) </span>{</span><br><span class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[sourceKey][key]</span><br><span class="line">  }</span><br><span class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span> (<span class="params">val</span>) </span>{</span><br><span class="line">    <span class="built_in">this</span>[sourceKey][key] = val</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>简单来讲，创建一个<code>vm.xxx</code>属性，当我们访问和修改这个属性时，其实是在访问和修改<code>vm._data.xxx</code>，这是就是为什么我们能够通过this来访问到data和props。</p></li><li><p><code>observe</code>：</p></li></ul><p><code>observe</code> 方法的作用就是给非 VNode 的对象类型数据添加一个 <code>Observer</code>，如果已经添加过则直接返回，否则在满足一定条件下去实例化一个 <code>Observer</code> 对象实例，Observer等一会介绍。</p><ul><li><code>defineReactive</code>：</li></ul><p><code>defineReactive</code> 的功能就是定义一个响应式对象，给对象动态添加 getter 和 setter，它的定义在 <code>src/core/observer/index.js</code> 中。</p><p>步骤：</p><ol><li>new Dep()。 </li><li>拿到 <code>obj</code> 的属性描述符，然后对子对象递归调用 <code>observe</code> 方法。</li></ol><h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><p>Observer步骤：</p><ol><li>new Dep()。</li><li>执行 <code>def</code> 函数把自身实例添加到数据对象 <code>value</code> 的 <code>__ob__</code> 属性上。</li><li>对数据<code>value</code>进行判断，如果是数组则遍历调用<code>observe</code>方法，如果是对象则调用 <code>walk</code> 方法，而 <code>walk</code> 方法是遍历对象的 key 调用 <code>defineReactive</code> 方法，那么我们来看一下这个方法是做什么的。</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observer class that is attached to each observed</span></span><br><span class="line"><span class="comment"> * object. Once attached, the observer converts the target</span></span><br><span class="line"><span class="comment"> * object's property keys into getter/setters that</span></span><br><span class="line"><span class="comment"> * collect dependencies and dispatch updates.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>{</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: number; <span class="comment">// number of vms that has this object as root $data</span></span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value: any</span>) {</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="built_in">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">    def(value, <span class="string">'__ob__'</span>, <span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) {</span><br><span class="line">      <span class="keyword">const</span> augment = hasProto</span><br><span class="line">        ? protoAugment</span><br><span class="line">        : copyAugment</span><br><span class="line">      augment(value, arrayMethods, arrayKeys)</span><br><span class="line">      <span class="built_in">this</span>.observeArray(value)</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="built_in">this</span>.walk(value)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Walk through each property and convert them into</span></span><br><span class="line"><span class="comment">   * getter/setters. This method should only be called when</span></span><br><span class="line"><span class="comment">   * value type is Object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  walk (obj: <span class="built_in">Object</span>) {</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) {</span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Observe a list of Array items.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) {</span><br><span class="line">      observe(items[i])</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h2><h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>{</span><br><span class="line">  <span class="keyword">static</span> target: ?Watcher; <span class="comment">// 静态属性target(Watcher类型)</span></span><br><span class="line">  id: number;</span><br><span class="line">  subs: <span class="built_in">Array</span>&lt;Watcher&gt;; <span class="comment">// 一个（Watcher类型）数组</span></span><br><span class="line">  </span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) {</span><br><span class="line">    <span class="built_in">this</span>.id = uid++</span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  addSub (sub: Watcher) {</span><br><span class="line">    <span class="comment">/* 为后续数据变化时候能通知到哪些 subs 做准备 */</span></span><br><span class="line">    <span class="built_in">this</span>.subs.push(sub)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  removeSub (sub: Watcher) {</span><br><span class="line">    remove(<span class="built_in">this</span>.subs, sub)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  depend () {</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) {</span><br><span class="line">      Dep.target.addDep(<span class="built_in">this</span>)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  notify () {</span><br><span class="line">    <span class="comment">/* 所有Watcher的实例对象 */</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="built_in">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) {</span><br><span class="line">      subs[i].update()</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>什么是依赖？</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>{{message}}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: {</span><br><span class="line">    text: <span class="string">'hello world'</span>,</span><br><span class="line">    message: <span class="string">'hello vue'</span>,</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch: {</span><br><span class="line">    message: <span class="function"><span class="keyword">function</span> (<span class="params">val, oldVal</span>) </span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'new: %s, old: %s'</span>, val, oldVal)</span><br><span class="line">    },</span><br><span class="line">}   </span><br></pre></td></tr></tbody></table></figure><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: {</span><br><span class="line">    <span class="function"><span class="title">messageT</span>(<span class="params"></span>)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.message + <span class="string">'!'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里可以看到，虽然data中有text和message，但只有message被使用了，因此只有message需要收集依赖。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2019/6/2/16b1857fd4532ff0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Dep如何收集依赖?</p><p>在getter中收集，当数据被访问时调用<code>dep.depend</code>。</p><p>什么是依赖？</p><p>其实就是<code>watcher</code>。</p><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>{</span><br><span class="line">  vm: Component;</span><br><span class="line">  deep: boolean;</span><br><span class="line">  sync: boolean;</span><br><span class="line">  deps: <span class="built_in">Array</span>&lt;Dep&gt;;</span><br><span class="line">  newDeps: <span class="built_in">Array</span>&lt;Dep&gt;;</span><br><span class="line">  depIds: SimpleSet;</span><br><span class="line">  newDepIds: SimpleSet;</span><br><span class="line">  before: ?<span class="built_in">Function</span>;</span><br><span class="line">  getter: <span class="built_in">Function</span>;</span><br><span class="line">  value: any;</span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">    vm: Component,</span></span><br><span class="line"><span class="params">    expOrFn: string | <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">    cb: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">    options?: ?<span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">    isRenderWatcher?: boolean</span></span><br><span class="line"><span class="params">  </span>) {</span><br><span class="line">    <span class="built_in">this</span>.vm = vm</span><br><span class="line">    vm._watchers.push(<span class="built_in">this</span>)</span><br><span class="line">    <span class="comment">/* 监听器的options */</span></span><br><span class="line">    <span class="keyword">if</span> (options) {</span><br><span class="line">      <span class="built_in">this</span>.deep = !!options.deep <span class="comment">// 深度监听</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="built_in">this</span>.sync = !!options.sync <span class="comment">// 在当前 Tick 中同步执行 watcher 的回调函数，否则响应式数据发生变化之后，watcher回调会在nextTick后执行；</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/* Watcher实例持有Dep的实例的数组 */</span></span><br><span class="line">    <span class="built_in">this</span>.deps = [] <span class="comment">// 老的Dep集合</span></span><br><span class="line">    <span class="built_in">this</span>.newDeps = [] <span class="comment">// 触发更新生成的新的Dep集合</span></span><br><span class="line">    <span class="built_in">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="built_in">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"></span><br><span class="line">  get () {</span><br><span class="line">    <span class="comment">/* 收集Watcher实例,也就是Dep.target */</span></span><br><span class="line">    pushTarget(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="built_in">this</span>.vm</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">/* this.getter对应就是我们上篇讲到的vm._update(vm._render(), hydrating),_update会生成VNode,在这个过程中会访</span></span><br><span class="line"><span class="comment">      问vm上的data，这时候就触发了数据对象的getter，defineReactive中可以发现每个getter都持有一个dep,</span></span><br><span class="line"><span class="comment">      因此在触发getter的时候会触发Dep的depend方法，也就触发了Watcher的addDep方法 */</span></span><br><span class="line">      value = <span class="built_in">this</span>.getter.call(vm, vm)</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">      <span class="comment">/* 把 Dep.target 恢复成上一个状态，因为当前 vm 的数据依赖收集已经完成，那么对应的渲染Dep.target 也需要改变 */</span></span><br><span class="line">      popTarget()</span><br><span class="line">      <span class="built_in">this</span>.cleanupDeps()</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  addDep (dep: Dep) {</span><br><span class="line">    <span class="keyword">const</span> id = dep.id</span><br><span class="line">    <span class="comment">/* 保证同一数据不会被添加多次 */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.newDepIds.has(id)) {</span><br><span class="line">      <span class="built_in">this</span>.newDepIds.add(id)</span><br><span class="line">      <span class="built_in">this</span>.newDeps.push(dep)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.depIds.has(id)) {</span><br><span class="line">        <span class="comment">/* 把当前的 watcher 订阅到这个数据持有的 dep 的 subs, 目的是为后续数据变化时候能通知到哪些 subs 做准备 */</span></span><br><span class="line">        dep.addSub(<span class="built_in">this</span>)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p> <code>watcher</code>中有两个方法:</p><ol><li><code>addDep</code>:看看自己依赖谁，然后告诉被依赖者，让自己进入被依赖者的<code>sub</code>名单。这样当被依赖者发生改变时就通知自己更新。</li><li><code>update</code>:当自己需要更新时调用，这个方法会在数据更新后渲染到页面上，并且调用<code>update</code>这个声明周期函数。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回顾一下，<code>Vue</code>响应式原理的核心就是<code>Observer</code>、<code>Dep</code>、<code>Watcher</code>。</p><p><code>Observer</code>中进行响应式的绑定，在数据被读的时候，触发<code>get</code>方法，执行<code>Dep</code>来收集依赖，也就是收集<code>Watcher</code>。</p><p>在数据被改的时候，触发<code>set</code>方法，通过对应的所有依赖(<code>Watcher</code>)，去执行更新。比如<code>watch</code>和<code>computed</code>就执行开发者自定义的回调方法。</p><p>本文参考了<a href="https://juejin.cn/post/6844903858850758670#heading-1%E3%80%82">https://juejin.cn/post/6844903858850758670#heading-1。</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本篇文章属于新手向，着重点在理解Vue响应式系统中的Observer、Dep、Watcher,这是理解响应式源码的关键。因此这篇文章不会在分析源码上花很多功夫。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://jrr997.github.io/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Vue" scheme="https://jrr997.github.io/blog/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码阅读(2)之组件化</title>
    <link href="https://jrr997.github.io/blog/2021/02/21/Vue-src-readding-2/"/>
    <id>https://jrr997.github.io/blog/2021/02/21/Vue-src-readding-2/</id>
    <published>2021-02-21T13:28:51.000Z</published>
    <updated>2021-02-21T13:33:02.563Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>组件化是Vue的一个核心思想。所谓组件化，就是把页面拆分成多个组件 (component)，每个组件依赖的 CSS、JavaScript、模板、图片等资源放在一起开发和维护。组件是资源独立的，组件在系统内部可复用，组件和组件之间可以嵌套。<a id="more"></a></p><p>本文主要关注Vue如何创建组件。</p><h2 id="createComponent"><a href="#createComponent" class="headerlink" title="createComponent"></a>createComponent</h2><p>在上一篇文章中介绍过<code>vm._render</code>方法，作用是根据<code>render</code>函数生成VDOM，生成VDOM主要是由<code>vm_render</code>方法中的<code>createElement</code>中的<code>_createElement</code>方法实现的。</p><p><code>_createElement</code>中有一段逻辑是对参数 <code>tag</code> 的判断，如果是一个普通的 html 标签，如div，则会实例化一个普通 VNode 节点，否则通过 <code>createComponent</code> 方法创建一个组件 VNode。</p><p><code>createComponent</code>有三个核心步骤：</p><ol><li>构造子类构造函数</li><li>安装组件钩子函数</li><li>实例化 VNode</li></ol><p>下面我会分别介绍这三个步骤。</p><h3 id="构造子类构造函数"><a href="#构造子类构造函数" class="headerlink" title="构造子类构造函数"></a>构造子类构造函数</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> baseCtor = context.$options._base</span><br><span class="line"></span><br><span class="line"><span class="comment">// plain options object: turn it into a constructor</span></span><br><span class="line"><span class="keyword">if</span> (isObject(Ctor)) {</span><br><span class="line">  Ctor = baseCtor.extend(Ctor)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里 <code>baseCtor</code> 实际上就是 Vue，这个的定义是在最开始初始化 Vue 的阶段，在 <code>src/core/global-api/index.js</code> 中的 <code>initGlobalAPI</code> 函数有这么一段逻辑：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this is used to identify the "base" constructor to extend all plain-object</span></span><br><span class="line"><span class="comment">// components with in Weex's multi-instance scenarios.</span></span><br><span class="line">Vue.options._base = Vue</span><br></pre></td></tr></tbody></table></figure><p>我们可以注意到<code>context.$options._base</code>和<code>Vue.options._base</code>，前者是实例中取出<code>_base</code>，后者是构造函数中取出<code>_base</code>,那么为什么这两个地方都能取出<code>_base</code>呢？</p><p>实际上在 <code>src/core/instance/init.js</code> 里 Vue 原型上的 <code>_init</code> 函数中有这么一段逻辑：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vm.$options = mergeOptions(</span><br><span class="line">  resolveConstructorOptions(vm.constructor),</span><br><span class="line">  options || {},</span><br><span class="line">  vm</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>这样就把 Vue 上的一些 <code>option</code> 扩展到了 vm.$options 上，意思是vm(组件)的<code>options</code>中包含了Vue的<code>options</code>和用户传入的<code>options</code>。</p><p>回到<code>Ctor = baseCtor.extend(Ctor)</code>，这里Ctor是Vue的子类，继承了Vue的属性和方法，extend返回的是一个叫<code>Sub</code>的组件构造函数。当我们去实例化<code>Sub</code>时，就会执行 <code>this._init</code> 逻辑再次走到了 <code>Vue</code> 实例的初始化逻辑，这意味着组件的实例化和Vue的实例化相类似。</p><h3 id="安装钩子函数"><a href="#安装钩子函数" class="headerlink" title="安装钩子函数"></a>安装钩子函数</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// install component management hooks onto the placeholder node</span></span><br><span class="line">installComponentHooks(data)</span><br></pre></td></tr></tbody></table></figure><p>整个 <code>installComponentHooks</code> 的过程就是把 <code>componentVNodeHooks</code> 的钩子函数合并到 <code>data.hook</code> 中，在 VNode 执行 <code>patch</code> 的过程中执行相关的钩子函数。</p><p>简单地说是把生成VNode的方法都准备好，准备生成Vnode。</p><h3 id="实例化VNode"><a href="#实例化VNode" class="headerlink" title="# 实例化VNode"></a># 实例化VNode</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = Ctor.options.name || tag</span><br><span class="line"><span class="keyword">const</span> vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">  <span class="string">`vue-component-<span class="subst">${Ctor.cid}</span><span class="subst">${name ? <span class="string">`-<span class="subst">${name}</span>`</span> : <span class="string">''</span>}</span>`</span>,</span><br><span class="line">  data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</span><br><span class="line">  { Ctor, propsData, listeners, tag, children },</span><br><span class="line">  asyncFactory</span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> vnode</span><br></pre></td></tr></tbody></table></figure><p>最后一步非常简单，通过 <code>new VNode</code> 实例化一个 <code>vnode</code> 并返回。需要注意的是和普通元素节点的 <code>vnode</code> 不同，组件的 <code>vnode</code> 是没有 <code>children</code> 的，这点很关键，在之后的 <code>patch</code> 过程中我们会再提。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>创建一个组件经历了三个步骤：</p><ol><li>创建组件的构造函数</li><li>执行构造函数，准备好生成Vnode的相关方法。</li><li>生成Vnode。</li></ol><p>下图是组件创建过程的函数调用栈，通过调用栈我们也能更好地了解组件的创建过程。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="C:\Users\Jrrr\Desktop\Chrome" alt="组件创建过程" title="Download组件创建过程.png">                </div>                <div class="image-caption">Download组件创建过程.png</div>            </figure><p>由下往上看，跟着函数调用栈的顺序，可以看出整个过程是</p><ul><li><p>执行 new Vue，然后初始化 vm 实例，扩展原型方法</p></li><li><p>执行 mount 函数去解析编译 template 模板</p></li><li><p>执行 Watcher render 去生成 VNode tree</p></li><li><p>执行 update 中的 patch 去生成 DOM，如遇到组件</p></li><li><ul><li>初始化 Sub 构造器</li><li>执行 new Sub，初始化组件 vm 实例，扩展原型方法</li><li>执行 mount 函数解析编译组件模板，生成组件 VNode tree，最终返回组件 DOM</li><li>如再遇组件，则继续递归</li></ul></li></ul><p>可以看出 Vue 的组件生成顺序是由子到父的。</p><h2 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h2><p>既然有了VNode，下一步应该是调用<code>vm._update</code>来创建真实DOM，这个过程就是patch。</p><p>具体的过程就不细说，这里主要注意一个组件中可能又包含另外的组件。如果组件 <code>patch</code> 过程中又创建了子组件，那么DOM 的插入顺序是先子后父。</p><h2 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h2><h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h3><p>相当于在<code>Vue.options.components</code>注册了一个组件。因为局部组件都会通过<code>Vue.extend</code>创建一个<code>Sub</code>子类(前面介绍过)，而<code>Sub</code>会继承<code>Vue.options.components</code>，这里是通过<code>mergeOptions</code>实现的，前面也简单提到过。</p><p>到这里，局部组件就能通过<code>options</code>拿到全局组件。</p><h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><p>Vue.js 也同样支持局部注册，我们可以在一个组件内部使用 <code>components</code> 选项做组件的局部注册，例如：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">'./components/HelloWorld'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  components: {</span><br><span class="line">    HelloWorld</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其实理解了全局注册的过程，局部注册是非常简单的。在组件的 Vue 的实例化阶段有一个合并 <code>option</code> 的逻辑，之前我们也分析过，所以就把 <code>components</code> 合并到 <code>vm.$options.components</code> 上，这样我们就可以在 <code>resolveAsset</code> 的时候拿到这个组件的构造函数，并作为 <code>createComponent</code> 的钩子的参数。</p><p>注意，局部注册和全局注册不同的是，只有该类型的组件才可以访问局部注册的子组件，而全局注册是扩展到 <code>Vue.options</code> 下，所以在所有组件创建的过程中，都会从全局的 <code>Vue.options.components</code> 扩展到当前组件的 <code>vm.$options.components</code> 下，这就是全局注册的组件能被任意使用的原因。</p><h2 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h2><p>因为我在实战中并没有用过异步组件，这里就先留个坑，只是简单的了解一下异步组件的作用。</p><p>在我们平时的开发工作中，为了减少首屏代码体积，往往会把一些非首屏的组件设计成异步组件，按需加载。Vue 也原生支持了异步组件的能力，如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-example'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>{</span><br><span class="line">   <span class="comment">// 这个特殊的 require 语法告诉 webpack</span></span><br><span class="line">   <span class="comment">// 自动将编译后的代码分割成不同的块，</span></span><br><span class="line">   <span class="comment">// 这些块将通过 Ajax 请求自动下载。</span></span><br><span class="line">   <span class="built_in">require</span>([<span class="string">'./my-async-component'</span>], resolve)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>生命周期是一个很重要的知识点，我要单独开一篇文章来讲。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;组件化是Vue的一个核心思想。所谓组件化，就是把页面拆分成多个组件 (component)，每个组件依赖的 CSS、JavaScript、模板、图片等资源放在一起开发和维护。组件是资源独立的，组件在系统内部可复用，组件和组件之间可以嵌套。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://jrr997.github.io/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Vue" scheme="https://jrr997.github.io/blog/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码阅读(1)之数据驱动</title>
    <link href="https://jrr997.github.io/blog/2021/02/20/vue-src-readding-1/"/>
    <id>https://jrr997.github.io/blog/2021/02/20/vue-src-readding-1/</id>
    <published>2021-02-20T15:58:19.000Z</published>
    <updated>2021-02-21T13:33:10.589Z</updated>
    
    <content type="html"><![CDATA[<h5 id="文章摘要：通过阅读Vue源码来深入学习Vue，本文章主要介绍Vue的数据驱动部分源码。"><a href="#文章摘要：通过阅读Vue源码来深入学习Vue，本文章主要介绍Vue的数据驱动部分源码。" class="headerlink" title="文章摘要：通过阅读Vue源码来深入学习Vue，本文章主要介绍Vue的数据驱动部分源码。"></a>文章摘要：通过阅读Vue源码来深入学习Vue，本文章主要介绍Vue的数据驱动部分源码。<a id="more"></a></h5><p>作为学习者，这篇文章主要是参考<a href="https://ustbhuangyi.github.io/vue-analysis/v2/prepare/">https://ustbhuangyi.github.io/vue-analysis/v2/prepare/</a></p><h1 id="Vue源码阅读"><a href="#Vue源码阅读" class="headerlink" title="Vue源码阅读"></a>Vue源码阅读</h1><h2 id="一、vue的源码目录设计"><a href="#一、vue的源码目录设计" class="headerlink" title="一、vue的源码目录设计"></a>一、vue的源码目录设计</h2><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├── compiler        # 编译相关 </span><br><span class="line">├── core            # 核心代码 </span><br><span class="line">├── platforms       # 不同平台的支持</span><br><span class="line">├── server          # 服务端渲染</span><br><span class="line">├── sfc             # .vue 文件解析</span><br><span class="line">├── shared          # 共享代码</span><br></pre></td></tr></tbody></table></figure><h4 id="compiler"><a href="#compiler" class="headerlink" title="compiler"></a>compiler</h4><p>compiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。</p><h4 id="core"><a href="#core" class="headerlink" title="core"></a>core</h4><p>core 目录包含了 Vue.js 的核心代码，包括内置组件、全局 API 封装，Vue 实例化、观察者、虚拟 DOM、工具函数等等。</p><h4 id="Vue入口"><a href="#Vue入口" class="headerlink" title="Vue入口"></a>Vue入口</h4><p>Vue入口在</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/core/instance/index.js</span><br></pre></td></tr></tbody></table></figure><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { initMixin } <span class="keyword">from</span> <span class="string">'./init'</span></span><br><span class="line"><span class="keyword">import</span> { stateMixin } <span class="keyword">from</span> <span class="string">'./state'</span></span><br><span class="line"><span class="keyword">import</span> { renderMixin } <span class="keyword">from</span> <span class="string">'./render'</span></span><br><span class="line"><span class="keyword">import</span> { eventsMixin } <span class="keyword">from</span> <span class="string">'./events'</span></span><br><span class="line"><span class="keyword">import</span> { lifecycleMixin } <span class="keyword">from</span> <span class="string">'./lifecycle'</span></span><br><span class="line"><span class="keyword">import</span> { warn } <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    !(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">  ) {</span><br><span class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">this</span>._init(options)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">initMixin(Vue)</span><br><span class="line">stateMixin(Vue)</span><br><span class="line">eventsMixin(Vue)</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line">renderMixin(Vue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></tbody></table></figure><p>这里可以看出Vue是一个构造函数。我们可以看到Vue被传入很多<code>xxxMixin</code> 函数中，这些函数的作用是给Vue.prototype扩展方法。</p><p><code>initGlobalAPI</code></p><p>Vue.js 在整个初始化过程中，除了给它的原型 prototype 上扩展方法，还会给 <code>Vue</code> 这个对象本身扩展全局的静态方法，它的定义在 <code>src/core/global-api/index.js</code> 中，全局方法包括set、delete、nextTick等。</p><h2 id="二、数据驱动"><a href="#二、数据驱动" class="headerlink" title="二、数据驱动"></a>二、数据驱动</h2><p>Vue.js 一个核心思想是数据驱动。数据驱动是指数据驱动视图的生成，我们只用修改数据，视图就会发生相应的修改，免去操作DOM来修改视图的步骤。</p><h4 id="new-Vue-发生了什么？"><a href="#new-Vue-发生了什么？" class="headerlink" title="new Vue 发生了什么？"></a>new Vue 发生了什么？</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    !(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">  ) {</span><br><span class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">this</span>._init(options)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从这里可见，new Vue后执行了this._init方法，并传入了options，而this_init方法主要做了这些事情：合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher 等等。下面是this._init的部分代码。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) {</span><br><span class="line">    initProxy(vm)</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    vm._renderProxy = vm</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// expose real self</span></span><br><span class="line">  vm._self = vm</span><br><span class="line">  initLifecycle(vm)</span><br><span class="line">  initEvents(vm)</span><br><span class="line">  initRender(vm)</span><br><span class="line">  callHook(vm, <span class="string">'beforeCreate'</span>)</span><br><span class="line">  initInjections(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">  initState(vm)</span><br><span class="line">  initProvide(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">  callHook(vm, <span class="string">'created'</span>)</span><br></pre></td></tr></tbody></table></figure><p>在beforeCreate前，Vue已经初始化了生命周期、时间和渲染，在beforeCreate和created之间有一个initState方法，initState主要是初始化data、props等属性。意思是beforeCreate不能拿到data、props、methods、computed等，要在created中拿。</p><h4 id="Vue实例的挂载"><a href="#Vue实例的挂载" class="headerlink" title="Vue实例的挂载"></a>Vue实例的挂载</h4><p><code>compiler</code> 版本的 <code>$mount</code> 实现非常有意思，先来看一下 <code>src/platform/web/entry-runtime-with-compiler.js</code> 文件中定义：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount</span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>{</span><br><span class="line">  el = el &amp;&amp; query(el)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) {</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = <span class="built_in">this</span>.$options</span><br><span class="line">  <span class="comment">// resolve template/el and convert to render function</span></span><br><span class="line">  <span class="keyword">if</span> (!options.render) {</span><br><span class="line">    <span class="keyword">let</span> template = options.template</span><br><span class="line">    <span class="keyword">if</span> (template) {</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">'string'</span>) {</span><br><span class="line">        <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">'#'</span>) {</span><br><span class="line">          template = idToTemplate(template)</span><br><span class="line">          <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">          <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !template) {</span><br><span class="line">            warn(</span><br><span class="line">              <span class="string">`Template element not found or is empty: <span class="subst">${options.template}</span>`</span>,</span><br><span class="line">              <span class="built_in">this</span></span><br><span class="line">            )</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) {</span><br><span class="line">        template = template.innerHTML</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) {</span><br><span class="line">          warn(<span class="string">'invalid template option:'</span> + template, <span class="built_in">this</span>)</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">      }</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (el) {</span><br><span class="line">      template = getOuterHTML(el)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (template) {</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) {</span><br><span class="line">        mark(<span class="string">'compile'</span>)</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> { render, staticRenderFns } = compileToFunctions(template, {</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        shouldDecodeNewlinesForHref,</span><br><span class="line">        delimiters: options.delimiters,</span><br><span class="line">        comments: options.comments</span><br><span class="line">      }, <span class="built_in">this</span>)</span><br><span class="line">      options.render = render</span><br><span class="line">      options.staticRenderFns = staticRenderFns</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) {</span><br><span class="line">        mark(<span class="string">'compile end'</span>)</span><br><span class="line">        measure(<span class="string">`vue <span class="subst">${<span class="built_in">this</span>._name}</span> compile`</span>, <span class="string">'compile'</span>, <span class="string">'compile end'</span>)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> mount.call(<span class="built_in">this</span>, el, hydrating)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在<code>runtime-with-compiler</code>版本的代码中，<code>const mount = Vue.prototype.$mount</code>缓存了<code>runtime-only</code>的<code>$mount</code>，然后重写了<code>$mount</code>方法，这个重写的<code>$mount</code>方法主要做了两件事情：</p><p>第一步：Vue实例通过<code>$mount </code>来挂载vm，且<code>$mount </code>限制Vue实例不能挂载到<code>body</code>和<code>html</code>根节点上。</p><p>第二步：把<code>el</code>和<code>template</code>字符串转化为<code>render</code>方法。Vue 2.0 版本中，所有 Vue 的组件的渲染最终都需要 <code>render</code> 方法。</p><p>做完这两步之后，会执行之前缓存的<code>runtime-only</code>的<code>$mount</code>。这个挂载是真正的挂载。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public mount method</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>{</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="built_in">this</span>, el, hydrating)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>原先的<code>$mount</code> 方法实际上会去调用 <code>mountComponent</code> 方法，这个方法定义在 <code>src/core/instance/lifecycle.js</code> 文件中：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  el: ?Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>{</span><br><span class="line">  vm.$el = el</span><br><span class="line">  <span class="keyword">if</span> (!vm.$options.render) {</span><br><span class="line">    vm.$options.render = createEmptyVNode</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) {</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> ((vm.$options.template &amp;&amp; vm.$options.template.charAt(<span class="number">0</span>) !== <span class="string">'#'</span>) ||</span><br><span class="line">        vm.$options.el || el) {</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'You are using the runtime-only build of Vue where the template '</span> +</span><br><span class="line">          <span class="string">'compiler is not available. Either pre-compile the templates into '</span> +</span><br><span class="line">          <span class="string">'render functions, or use the compiler-included build.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'Failed to mount component: template or render function not defined.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  callHook(vm, <span class="string">'beforeMount'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) {</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="keyword">const</span> name = vm._name</span><br><span class="line">      <span class="keyword">const</span> id = vm._uid</span><br><span class="line">      <span class="keyword">const</span> startTag = <span class="string">`vue-perf-start:<span class="subst">${id}</span>`</span></span><br><span class="line">      <span class="keyword">const</span> endTag = <span class="string">`vue-perf-end:<span class="subst">${id}</span>`</span></span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      <span class="keyword">const</span> vnode = vm._render()</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">${name}</span> render`</span>, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      vm._update(vnode, hydrating)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">${name}</span> patch`</span>, startTag, endTag)</span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> {</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher's constructor</span></span><br><span class="line">  <span class="comment">// since the watcher's initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component's mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, {</span><br><span class="line">    before () {</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted) {</span><br><span class="line">        callHook(vm, <span class="string">'beforeUpdate'</span>)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) {</span><br><span class="line">    vm._isMounted = <span class="literal">true</span></span><br><span class="line">    callHook(vm, <span class="string">'mounted'</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这段代码说明了<code>mountComponent</code>做了两件事情：</p><ol><li>调用 <code>vm._render</code>生成了VNode，最终调用 <code>vm._update</code> 更新 DOM。</li><li>创建<code>Watcher</code>实例，而<code>watcher</code>做又做了两件事情：<ul><li>一个是初始化的时候会执行回调函数<code>callHook(vm, 'mounted')</code></li><li>二是当vm 实例中的监测的数据发生变化的时候执行回调函数```callHook(vm, ‘beforeUpdate’)``</li></ul></li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol><li>模板转化成render函数。</li><li><code>vm._render</code>生成了VNode。</li><li><code>callHook(vm, 'beforeUpdate')</code></li><li><code>vm._update</code> 更新 DOM。</li><li><code>callHook(vm, 'mounted')</code>或者<code>callHook(vm, 'beforeUpdate')</code></li></ol><h4 id="vm-render"><a href="#vm-render" class="headerlink" title="vm._render"></a>vm._render</h4><p>前面提到<code>vm._render</code>,这个方法的作用就是把<code>render</code>函数生成VNode，也就是虚拟DOM。</p><p>模板：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  {{ message }}</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>模板转为<code>render</code>函数：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">'div'</span>, {</span><br><span class="line">     attrs: {</span><br><span class="line">        id: <span class="string">'app'</span></span><br><span class="line">      },</span><br><span class="line">  }, <span class="built_in">this</span>.message)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>vm._render</code>方法传入<code>render</code>函数，生成VNode，这里的<code>$createElement</code>就是创建VNode的方法。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnode = render.call(vm._renderProxy, vm.$createElement)</span><br></pre></td></tr></tbody></table></figure><h4 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h4><p>首先必须知道为什么需要虚拟DOM？</p><p>因为浏览器的DOM是十分“昂贵”的，真实DOM十分庞大，每个真实DOM都有很多属性和方法。如果我们频繁地更新真实DOM，可能会出现性能问题，因此虚拟DOM就出现了。</p><p>那么什么是虚拟DOM？</p><p>虚拟DOM就是描述真实DOM的JS对象，与真实DOM对比起来，虚拟DOM是轻量的。它的核心定义无非就几个关键属性，标签名、数据、子节点、键值等。</p><p>虚拟DOM除了它的数据结构的定义，映射到真实的 DOM 实际上要经历 VNode 的 create、diff、patch 等过程。那么在 Vue.js 中，VNode 的 create 是通过之前提到的 <code>createElement</code> 方法创建的，我们接下来分析这部分的实现。</p><h4 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h4><p><code>createElement</code>做两件事情</p><ol><li><p>children 的规范化</p><p>由于 Virtual DOM 实际上是一个树状结构，每一个 VNode 可能会有若干个子节点，这些子节点应该也是 VNode 的类型。<code>_createElement</code> 接收的第 4 个参数 children 是任意类型的，因此我们需要把它们规范成 VNode 类型。</p><p>在大多数情况下children都是VNode类型的，但也有例外就是 <code>functional component</code> 函数式组件返回的是一个数组而不是一个根节点，所以会通过 <code>Array.prototype.concat</code> 方法把整个 <code>children</code> 数组打平，让它的深度只有一层。</p></li><li><p>VNode 的创建</p><ul><li><p>单节点就直接创建一个VNode。</p></li><li><p>如果是多个节点，会用数组表示，遍历创建VNode。</p></li><li><p>有时候数组中会嵌套数组，这时用递归。</p></li></ul></li></ol><p>经过这两个步骤就形成了一个 VNode Tree。</p><p>回到 <code>mountComponent</code> 函数的过程，我们已经知道 <code>vm._render</code> 是如何创建了一个 VNode，接下来就是要把这个 VNode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过 <code>vm._update</code> 完成的，接下来分析一下这个过程。</p><h4 id="vm-update"><a href="#vm-update" class="headerlink" title="vm._update"></a>vm._update</h4><p>Vue 的 <code>_update</code> 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候；由于我们这一章节只分析首次渲染部分，数据更新部分会在之后分析响应式原理的时候涉及。<code>_update</code> 方法的作用是把 VNode 渲染成真实的 DOM，它的定义在 <code>src/core/instance/lifecycle.js</code> 中。</p><p>首次渲染时vm._update的主要是调用一个<code>patch</code>方法</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// initial render</span><br><span class="line">vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)</span><br></pre></td></tr></tbody></table></figure><p>其中<code>patch</code>方法又有一个<code>creatElm</code>方法，作用是根据虚拟DOM创建真实DOM。</p><p>简单地讲，在首次渲染时，<code>_update</code>方法根据虚拟DOM数创建一个真实的DOM树然后插入到<code>vm.$el</code>上。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>那么至此我们从主线上把模板和数据如何渲染成最终的 DOM 的过程分析完毕了，我们可以通过下图更直观地看到从初始化 Vue 到最终渲染的整个过程。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ustbhuangyi.github.io/vue-analysis/assets/new-vue.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;文章摘要：通过阅读Vue源码来深入学习Vue，本文章主要介绍Vue的数据驱动部分源码。&quot;&gt;&lt;a href=&quot;#文章摘要：通过阅读Vue源码来深入学习Vue，本文章主要介绍Vue的数据驱动部分源码。&quot; class=&quot;headerlink&quot; title=&quot;文章摘要：通过阅读Vue源码来深入学习Vue，本文章主要介绍Vue的数据驱动部分源码。&quot;&gt;&lt;/a&gt;文章摘要：通过阅读Vue源码来深入学习Vue，本文章主要介绍Vue的数据驱动部分源码。&lt;/h5&gt;</summary>
    
    
    
    <category term="技术" scheme="https://jrr997.github.io/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Vue" scheme="https://jrr997.github.io/blog/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>这是一段很长很长很长很长很长很长很长很长很长很长的文字，用来测试一下标题</title>
    <link href="https://jrr997.github.io/blog/2021/02/18/test/"/>
    <id>https://jrr997.github.io/blog/2021/02/18/test/</id>
    <published>2021-02-17T16:26:21.000Z</published>
    <updated>2021-02-21T13:33:35.347Z</updated>
    
    <content type="html"><![CDATA[<h5 id="测试。"><a href="#测试。" class="headerlink" title="测试。"></a>测试。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;测试。&quot;&gt;&lt;a href=&quot;#测试。&quot; class=&quot;headerlink&quot; title=&quot;测试。&quot;&gt;&lt;/a&gt;测试。&lt;/h5&gt;</summary>
      
    
    
    
    <category term="日常" scheme="https://jrr997.github.io/blog/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="博客" scheme="https://jrr997.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>记录博客建站完成</title>
    <link href="https://jrr997.github.io/blog/2021/02/17/My-New-Post/"/>
    <id>https://jrr997.github.io/blog/2021/02/17/My-New-Post/</id>
    <published>2021-02-17T10:43:02.000Z</published>
    <updated>2021-02-21T13:34:09.514Z</updated>
    
    <content type="html"><![CDATA[<h5 id="文章摘要：记录博客建立完成及过程中遇到的坑"><a href="#文章摘要：记录博客建立完成及过程中遇到的坑" class="headerlink" title="文章摘要：记录博客建立完成及过程中遇到的坑"></a>文章摘要：记录博客建立完成及过程中遇到的坑<a id="more"></a></h5><h5 id="emsp-emsp-记录一下自己的博客顺利建成！"><a href="#emsp-emsp-记录一下自己的博客顺利建成！" class="headerlink" title="  记录一下自己的博客顺利建成！"></a>  记录一下自己的博客顺利建成！<br></h5><h5 id="emsp-emsp-本以为用HEXO建个博客挺容易的，结果还是踩了很多坑，不过最终还是顺利完成这个博客。"><a href="#emsp-emsp-本以为用HEXO建个博客挺容易的，结果还是踩了很多坑，不过最终还是顺利完成这个博客。" class="headerlink" title="  本以为用HEXO建个博客挺容易的，结果还是踩了很多坑，不过最终还是顺利完成这个博客。"></a>  本以为用HEXO建个博客挺容易的，结果还是踩了很多坑，不过最终还是顺利完成这个博客。<br></h5><h5 id="emsp-emsp-顺便记录一下这些坑吧。"><a href="#emsp-emsp-顺便记录一下这些坑吧。" class="headerlink" title="  顺便记录一下这些坑吧。"></a>  顺便记录一下这些坑吧。<br></h5><h5 id="第一个大坑"><a href="#第一个大坑" class="headerlink" title="第一个大坑:"></a>第一个大坑:<br></h5><h5 id="emsp-emsp-首先是博客主题的作者使用ejs来写的，按照主题的文档步骤来还是会报错，错误是-is-not-defined-in-XXX…，这里应该是这个博客最麻烦的地方，我并不知道这个-代表的是什么。"><a href="#emsp-emsp-首先是博客主题的作者使用ejs来写的，按照主题的文档步骤来还是会报错，错误是-is-not-defined-in-XXX…，这里应该是这个博客最麻烦的地方，我并不知道这个-代表的是什么。" class="headerlink" title="  首先是博客主题的作者使用ejs来写的，按照主题的文档步骤来还是会报错，错误是_ is not defined in XXX…，这里应该是这个博客最麻烦的地方，我并不知道这个_代表的是什么。"></a>  首先是博客主题的作者使用ejs来写的，按照主题的文档步骤来还是会报错，错误是_ is not defined in XXX…，这里应该是这个博客最麻烦的地方，我并不知道这个_代表的是什么。<br></h5><h5 id="emsp-emsp-后来据我观察，作者在三个地方都用到-XX方法，且三个地方只要执行了就会报错，其中作者用到了-template和-isArray-。"><a href="#emsp-emsp-后来据我观察，作者在三个地方都用到-XX方法，且三个地方只要执行了就会报错，其中作者用到了-template和-isArray-。" class="headerlink" title="  后来据我观察，作者在三个地方都用到 _.XX方法，且三个地方只要执行了就会报错，其中作者用到了_.template和_.isArray()。"></a>  后来据我观察，作者在三个地方都用到 _.XX方法，且三个地方只要执行了就会报错，其中作者用到了_.template和_.isArray()。<br></h5><h5 id="emsp-emsp-我盲猜作者是在ejs中使用了jquery，而这个-就是-的另外写法，但是我在往上并找不到相关的资料-VPN碰巧今晚过期了，因此可能没找详细。"><a href="#emsp-emsp-我盲猜作者是在ejs中使用了jquery，而这个-就是-的另外写法，但是我在往上并找不到相关的资料-VPN碰巧今晚过期了，因此可能没找详细。" class="headerlink" title="  我盲猜作者是在ejs中使用了jquery，而这个_就是$的另外写法，但是我在往上并找不到相关的资料(VPN碰巧今晚过期了，因此可能没找详细。)"></a>  我盲猜作者是在ejs中使用了jquery，而这个_就是$的另外写法，但是我在往上并找不到相关的资料(VPN碰巧今晚过期了，因此可能没找详细。)<br></h5><h5 id="emsp-emsp-我也不想在这个地方纠结了，于是只能将计就计，把有-的地方都删掉，或者用顺着思路其他方法代替，终于博客没报错并且能运行。"><a href="#emsp-emsp-我也不想在这个地方纠结了，于是只能将计就计，把有-的地方都删掉，或者用顺着思路其他方法代替，终于博客没报错并且能运行。" class="headerlink" title="  我也不想在这个地方纠结了，于是只能将计就计，把有_的地方都删掉，或者用顺着思路其他方法代替，终于博客没报错并且能运行。"></a>  我也不想在这个地方纠结了，于是只能将计就计，把有_的地方都删掉，或者用顺着思路其他方法代替，终于博客没报错并且能运行。<br><br></h5><h5 id="第二个大坑"><a href="#第二个大坑" class="headerlink" title="第二个大坑:"></a>第二个大坑:<br></h5><h5 id="emsp-emsp-点击阅读全文后，并没有显示内容，其中有部分原因是因为这个-，不过解决后还是没显示内容。但是审查元素发现其实内容是有的，这就让我怀疑是display-none，搞的鬼，但事实并不是这样。"><a href="#emsp-emsp-点击阅读全文后，并没有显示内容，其中有部分原因是因为这个-，不过解决后还是没显示内容。但是审查元素发现其实内容是有的，这就让我怀疑是display-none，搞的鬼，但事实并不是这样。" class="headerlink" title="  点击阅读全文后，并没有显示内容，其中有部分原因是因为这个__，不过解决后还是没显示内容。但是审查元素发现其实内容是有的，这就让我怀疑是display:none，搞的鬼，但事实并不是这样。"></a>  点击阅读全文后，并没有显示内容，其中有部分原因是因为这个__，不过解决后还是没显示内容。但是审查元素发现其实内容是有的，这就让我怀疑是display:none，搞的鬼，但事实并不是这样。<br></h5><h5 id="emsp-emsp-后来我改变浏览器窗口大小，当浏览器窗口宽度小于480px时居然显示出了内容，而且还是有动画的，然后我以为是动画的问题，于是往JS的方向找，结果被打脸了——找不到。"><a href="#emsp-emsp-后来我改变浏览器窗口大小，当浏览器窗口宽度小于480px时居然显示出了内容，而且还是有动画的，然后我以为是动画的问题，于是往JS的方向找，结果被打脸了——找不到。" class="headerlink" title="  后来我改变浏览器窗口大小，当浏览器窗口宽度小于480px时居然显示出了内容，而且还是有动画的，然后我以为是动画的问题，于是往JS的方向找，结果被打脸了——找不到。"></a>  后来我改变浏览器窗口大小，当浏览器窗口宽度小于480px时居然显示出了内容，而且还是有动画的，然后我以为是动画的问题，于是往JS的方向找，结果被打脸了——找不到。<br></h5><h5 id="emsp-emsp-那只剩下一个可能了——css的媒体查询。作者是通过opacity来隐藏页面的，我也不知道他为什么要隐藏，我把内容的opacity改成1就能一直显示了。"><a href="#emsp-emsp-那只剩下一个可能了——css的媒体查询。作者是通过opacity来隐藏页面的，我也不知道他为什么要隐藏，我把内容的opacity改成1就能一直显示了。" class="headerlink" title="  那只剩下一个可能了——css的媒体查询。作者是通过opacity来隐藏页面的，我也不知道他为什么要隐藏，我把内容的opacity改成1就能一直显示了。"></a>  那只剩下一个可能了——css的媒体查询。作者是通过opacity来隐藏页面的，我也不知道他为什么要隐藏，我把内容的opacity改成1就能一直显示了。</h5><h5 id="emsp-emsp-其实这个博客很多功能还不完善，后续我会接着更新。"><a href="#emsp-emsp-其实这个博客很多功能还不完善，后续我会接着更新。" class="headerlink" title="  其实这个博客很多功能还不完善，后续我会接着更新。"></a>  其实这个博客很多功能还不完善，后续我会接着更新。</h5><h5 id="emsp-emsp-最后祝贺自己成功搭建这个博客。"><a href="#emsp-emsp-最后祝贺自己成功搭建这个博客。" class="headerlink" title="  最后祝贺自己成功搭建这个博客。"></a>  最后祝贺自己成功搭建这个博客。</h5>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;文章摘要：记录博客建立完成及过程中遇到的坑&quot;&gt;&lt;a href=&quot;#文章摘要：记录博客建立完成及过程中遇到的坑&quot; class=&quot;headerlink&quot; title=&quot;文章摘要：记录博客建立完成及过程中遇到的坑&quot;&gt;&lt;/a&gt;文章摘要：记录博客建立完成及过程中遇到的坑&lt;/h5&gt;</summary>
    
    
    
    <category term="日常" scheme="https://jrr997.github.io/blog/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="博客" scheme="https://jrr997.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
