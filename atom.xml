<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  <subtitle>Blog</subtitle>
  <link href="https://jrr997.github.io/blog/atom.xml" rel="self"/>
  
  <link href="https://jrr997.github.io/blog/"/>
  <updated>2021-02-20T16:12:21.741Z</updated>
  <id>https://jrr997.github.io/blog/</id>
  
  <author>
    <name>Zack Chang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue源码阅读(1)</title>
    <link href="https://jrr997.github.io/blog/2021/02/20/vue-src-readding-1/"/>
    <id>https://jrr997.github.io/blog/2021/02/20/vue-src-readding-1/</id>
    <published>2021-02-20T15:58:19.000Z</published>
    <updated>2021-02-20T16:12:21.741Z</updated>
    
    <content type="html"><![CDATA[<h5 id="文章摘要：通过阅读Vue源码来深入学习Vue，本文章主要介绍Vue的数据驱动部分源码。"><a href="#文章摘要：通过阅读Vue源码来深入学习Vue，本文章主要介绍Vue的数据驱动部分源码。" class="headerlink" title="文章摘要：通过阅读Vue源码来深入学习Vue，本文章主要介绍Vue的数据驱动部分源码。"></a>文章摘要：通过阅读Vue源码来深入学习Vue，本文章主要介绍Vue的数据驱动部分源码。<a id="more"></a></h5><p>作为学习者，这篇文章主要是参考<a href="https://ustbhuangyi.github.io/vue-analysis/v2/prepare/">https://ustbhuangyi.github.io/vue-analysis/v2/prepare/</a></p><h1 id="Vue源码阅读"><a href="#Vue源码阅读" class="headerlink" title="Vue源码阅读"></a>Vue源码阅读</h1><h2 id="一、vue的源码目录设计"><a href="#一、vue的源码目录设计" class="headerlink" title="一、vue的源码目录设计"></a>一、vue的源码目录设计</h2><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├── compiler        # 编译相关 </span><br><span class="line">├── core            # 核心代码 </span><br><span class="line">├── platforms       # 不同平台的支持</span><br><span class="line">├── server          # 服务端渲染</span><br><span class="line">├── sfc             # .vue 文件解析</span><br><span class="line">├── shared          # 共享代码</span><br></pre></td></tr></tbody></table></figure><h4 id="compiler"><a href="#compiler" class="headerlink" title="compiler"></a>compiler</h4><p>compiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。</p><h4 id="core"><a href="#core" class="headerlink" title="core"></a>core</h4><p>core 目录包含了 Vue.js 的核心代码，包括内置组件、全局 API 封装，Vue 实例化、观察者、虚拟 DOM、工具函数等等。</p><h4 id="Vue入口"><a href="#Vue入口" class="headerlink" title="Vue入口"></a>Vue入口</h4><p>Vue入口在</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/core/instance/index.js</span><br></pre></td></tr></tbody></table></figure><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { initMixin } <span class="keyword">from</span> <span class="string">'./init'</span></span><br><span class="line"><span class="keyword">import</span> { stateMixin } <span class="keyword">from</span> <span class="string">'./state'</span></span><br><span class="line"><span class="keyword">import</span> { renderMixin } <span class="keyword">from</span> <span class="string">'./render'</span></span><br><span class="line"><span class="keyword">import</span> { eventsMixin } <span class="keyword">from</span> <span class="string">'./events'</span></span><br><span class="line"><span class="keyword">import</span> { lifecycleMixin } <span class="keyword">from</span> <span class="string">'./lifecycle'</span></span><br><span class="line"><span class="keyword">import</span> { warn } <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    !(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">  ) {</span><br><span class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">this</span>._init(options)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">initMixin(Vue)</span><br><span class="line">stateMixin(Vue)</span><br><span class="line">eventsMixin(Vue)</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line">renderMixin(Vue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></tbody></table></figure><p>这里可以看出Vue是一个构造函数。我们可以看到Vue被传入很多<code>xxxMixin</code> 函数中，这些函数的作用是给Vue.prototype扩展方法。</p><p><code>initGlobalAPI</code></p><p>Vue.js 在整个初始化过程中，除了给它的原型 prototype 上扩展方法，还会给 <code>Vue</code> 这个对象本身扩展全局的静态方法，它的定义在 <code>src/core/global-api/index.js</code> 中，全局方法包括set、delete、nextTick等。</p><h2 id="二、数据驱动"><a href="#二、数据驱动" class="headerlink" title="二、数据驱动"></a>二、数据驱动</h2><p>Vue.js 一个核心思想是数据驱动。数据驱动是指数据驱动视图的生成，我们只用修改数据，视图就会发生相应的修改，免去操作DOM来修改视图的步骤。</p><h4 id="new-Vue-发生了什么？"><a href="#new-Vue-发生了什么？" class="headerlink" title="new Vue 发生了什么？"></a>new Vue 发生了什么？</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    !(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">  ) {</span><br><span class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">this</span>._init(options)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从这里可见，new Vue后执行了this._init方法，并传入了options，而this_init方法主要做了这些事情：合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher 等等。下面是this._init的部分代码。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) {</span><br><span class="line">    initProxy(vm)</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    vm._renderProxy = vm</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// expose real self</span></span><br><span class="line">  vm._self = vm</span><br><span class="line">  initLifecycle(vm)</span><br><span class="line">  initEvents(vm)</span><br><span class="line">  initRender(vm)</span><br><span class="line">  callHook(vm, <span class="string">'beforeCreate'</span>)</span><br><span class="line">  initInjections(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">  initState(vm)</span><br><span class="line">  initProvide(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">  callHook(vm, <span class="string">'created'</span>)</span><br></pre></td></tr></tbody></table></figure><p>在beforeCreate前，Vue已经初始化了生命周期、时间和渲染，在beforeCreate和created之间有一个initState方法，initState主要是初始化data、props等属性。意思是beforeCreate不能拿到data、props、methods、computed等，要在created中拿。</p><h4 id="Vue实例的挂载"><a href="#Vue实例的挂载" class="headerlink" title="Vue实例的挂载"></a>Vue实例的挂载</h4><p><code>compiler</code> 版本的 <code>$mount</code> 实现非常有意思，先来看一下 <code>src/platform/web/entry-runtime-with-compiler.js</code> 文件中定义：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount</span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>{</span><br><span class="line">  el = el &amp;&amp; query(el)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) {</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = <span class="built_in">this</span>.$options</span><br><span class="line">  <span class="comment">// resolve template/el and convert to render function</span></span><br><span class="line">  <span class="keyword">if</span> (!options.render) {</span><br><span class="line">    <span class="keyword">let</span> template = options.template</span><br><span class="line">    <span class="keyword">if</span> (template) {</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">'string'</span>) {</span><br><span class="line">        <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">'#'</span>) {</span><br><span class="line">          template = idToTemplate(template)</span><br><span class="line">          <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">          <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !template) {</span><br><span class="line">            warn(</span><br><span class="line">              <span class="string">`Template element not found or is empty: <span class="subst">${options.template}</span>`</span>,</span><br><span class="line">              <span class="built_in">this</span></span><br><span class="line">            )</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) {</span><br><span class="line">        template = template.innerHTML</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) {</span><br><span class="line">          warn(<span class="string">'invalid template option:'</span> + template, <span class="built_in">this</span>)</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">      }</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (el) {</span><br><span class="line">      template = getOuterHTML(el)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (template) {</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) {</span><br><span class="line">        mark(<span class="string">'compile'</span>)</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> { render, staticRenderFns } = compileToFunctions(template, {</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        shouldDecodeNewlinesForHref,</span><br><span class="line">        delimiters: options.delimiters,</span><br><span class="line">        comments: options.comments</span><br><span class="line">      }, <span class="built_in">this</span>)</span><br><span class="line">      options.render = render</span><br><span class="line">      options.staticRenderFns = staticRenderFns</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) {</span><br><span class="line">        mark(<span class="string">'compile end'</span>)</span><br><span class="line">        measure(<span class="string">`vue <span class="subst">${<span class="built_in">this</span>._name}</span> compile`</span>, <span class="string">'compile'</span>, <span class="string">'compile end'</span>)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> mount.call(<span class="built_in">this</span>, el, hydrating)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在<code>runtime-with-compiler</code>版本的代码中，<code>const mount = Vue.prototype.$mount</code>缓存了<code>runtime-only</code>的<code>$mount</code>，然后重写了<code>$mount</code>方法，这个重写的<code>$mount</code>方法主要做了两件事情：</p><p>第一步：Vue实例通过<code>$mount </code>来挂载vm，且<code>$mount </code>限制Vue实例不能挂载到<code>body</code>和<code>html</code>根节点上。</p><p>第二步：把<code>el</code>和<code>template</code>字符串转化为<code>render</code>方法。Vue 2.0 版本中，所有 Vue 的组件的渲染最终都需要 <code>render</code> 方法。</p><p>做完这两步之后，会执行之前缓存的<code>runtime-only</code>的<code>$mount</code>。这个挂载是真正的挂载。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public mount method</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>{</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="built_in">this</span>, el, hydrating)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>原先的<code>$mount</code> 方法实际上会去调用 <code>mountComponent</code> 方法，这个方法定义在 <code>src/core/instance/lifecycle.js</code> 文件中：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  el: ?Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>{</span><br><span class="line">  vm.$el = el</span><br><span class="line">  <span class="keyword">if</span> (!vm.$options.render) {</span><br><span class="line">    vm.$options.render = createEmptyVNode</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) {</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> ((vm.$options.template &amp;&amp; vm.$options.template.charAt(<span class="number">0</span>) !== <span class="string">'#'</span>) ||</span><br><span class="line">        vm.$options.el || el) {</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'You are using the runtime-only build of Vue where the template '</span> +</span><br><span class="line">          <span class="string">'compiler is not available. Either pre-compile the templates into '</span> +</span><br><span class="line">          <span class="string">'render functions, or use the compiler-included build.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'Failed to mount component: template or render function not defined.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  callHook(vm, <span class="string">'beforeMount'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) {</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="keyword">const</span> name = vm._name</span><br><span class="line">      <span class="keyword">const</span> id = vm._uid</span><br><span class="line">      <span class="keyword">const</span> startTag = <span class="string">`vue-perf-start:<span class="subst">${id}</span>`</span></span><br><span class="line">      <span class="keyword">const</span> endTag = <span class="string">`vue-perf-end:<span class="subst">${id}</span>`</span></span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      <span class="keyword">const</span> vnode = vm._render()</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">${name}</span> render`</span>, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      vm._update(vnode, hydrating)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">${name}</span> patch`</span>, startTag, endTag)</span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> {</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher's constructor</span></span><br><span class="line">  <span class="comment">// since the watcher's initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component's mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, {</span><br><span class="line">    before () {</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted) {</span><br><span class="line">        callHook(vm, <span class="string">'beforeUpdate'</span>)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) {</span><br><span class="line">    vm._isMounted = <span class="literal">true</span></span><br><span class="line">    callHook(vm, <span class="string">'mounted'</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这段代码说明了<code>mountComponent</code>做了两件事情：</p><ol><li>调用 <code>vm._render</code>生成了VNode，最终调用 <code>vm._update</code> 更新 DOM。</li><li>创建<code>Watcher</code>实例，而<code>watcher</code>做又做了两件事情：<ul><li>一个是初始化的时候会执行回调函数<code>callHook(vm, 'mounted')</code></li><li>二是当vm 实例中的监测的数据发生变化的时候执行回调函数```callHook(vm, ‘beforeUpdate’)``</li></ul></li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol><li>模板转化成render函数。</li><li><code>vm._render</code>生成了VNode。</li><li><code>callHook(vm, 'beforeUpdate')</code></li><li><code>vm._update</code> 更新 DOM。</li><li><code>callHook(vm, 'mounted')</code>或者<code>callHook(vm, 'beforeUpdate')</code></li></ol><h4 id="vm-render"><a href="#vm-render" class="headerlink" title="vm._render"></a>vm._render</h4><p>前面提到<code>vm._render</code>,这个方法的作用就是把<code>render</code>函数生成VNode，也就是虚拟DOM。</p><p>模板：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  {{ message }}</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>模板转为<code>render</code>函数：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">'div'</span>, {</span><br><span class="line">     attrs: {</span><br><span class="line">        id: <span class="string">'app'</span></span><br><span class="line">      },</span><br><span class="line">  }, <span class="built_in">this</span>.message)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>vm._render</code>方法传入<code>render</code>函数，生成VNode，这里的<code>$createElement</code>就是创建VNode的方法。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnode = render.call(vm._renderProxy, vm.$createElement)</span><br></pre></td></tr></tbody></table></figure><h4 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h4><p>首先必须知道为什么需要虚拟DOM？</p><p>因为浏览器的DOM是十分“昂贵”的，真实DOM十分庞大，每个真实DOM都有很多属性和方法。如果我们频繁地更新真实DOM，可能会出现性能问题，因此虚拟DOM就出现了。</p><p>那么什么是虚拟DOM？</p><p>虚拟DOM就是描述真实DOM的JS对象，与真实DOM对比起来，虚拟DOM是轻量的。它的核心定义无非就几个关键属性，标签名、数据、子节点、键值等。</p><p>虚拟DOM除了它的数据结构的定义，映射到真实的 DOM 实际上要经历 VNode 的 create、diff、patch 等过程。那么在 Vue.js 中，VNode 的 create 是通过之前提到的 <code>createElement</code> 方法创建的，我们接下来分析这部分的实现。</p><h4 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h4><p><code>createElement</code>做两件事情</p><ol><li><p>children 的规范化</p><p>由于 Virtual DOM 实际上是一个树状结构，每一个 VNode 可能会有若干个子节点，这些子节点应该也是 VNode 的类型。<code>_createElement</code> 接收的第 4 个参数 children 是任意类型的，因此我们需要把它们规范成 VNode 类型。</p><p>在大多数情况下children都是VNode类型的，但也有例外就是 <code>functional component</code> 函数式组件返回的是一个数组而不是一个根节点，所以会通过 <code>Array.prototype.concat</code> 方法把整个 <code>children</code> 数组打平，让它的深度只有一层。</p></li><li><p>VNode 的创建</p><ul><li><p>单节点就直接创建一个VNode。</p></li><li><p>如果是多个节点，会用数组表示，遍历创建VNode。</p></li><li><p>有时候数组中会嵌套数组，这时用递归。</p></li></ul></li></ol><p>经过这两个步骤就形成了一个 VNode Tree。</p><p>回到 <code>mountComponent</code> 函数的过程，我们已经知道 <code>vm._render</code> 是如何创建了一个 VNode，接下来就是要把这个 VNode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过 <code>vm._update</code> 完成的，接下来分析一下这个过程。</p><h4 id="vm-update"><a href="#vm-update" class="headerlink" title="vm._update"></a>vm._update</h4><p>Vue 的 <code>_update</code> 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候；由于我们这一章节只分析首次渲染部分，数据更新部分会在之后分析响应式原理的时候涉及。<code>_update</code> 方法的作用是把 VNode 渲染成真实的 DOM，它的定义在 <code>src/core/instance/lifecycle.js</code> 中。</p><p>首次渲染时vm._update的主要是调用一个<code>patch</code>方法</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// initial render</span><br><span class="line">vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)</span><br></pre></td></tr></tbody></table></figure><p>其中<code>patch</code>方法又有一个<code>creatElm</code>方法，作用是根据虚拟DOM创建真实DOM。</p><p>简单地讲，在首次渲染时，<code>_update</code>方法根据虚拟DOM数创建一个真实的DOM树然后插入到<code>vm.$el</code>上。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>那么至此我们从主线上把模板和数据如何渲染成最终的 DOM 的过程分析完毕了，我们可以通过下图更直观地看到从初始化 Vue 到最终渲染的整个过程。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ustbhuangyi.github.io/vue-analysis/assets/new-vue.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;文章摘要：通过阅读Vue源码来深入学习Vue，本文章主要介绍Vue的数据驱动部分源码。&quot;&gt;&lt;a href=&quot;#文章摘要：通过阅读Vue源码来深入学习Vue，本文章主要介绍Vue的数据驱动部分源码。&quot; class=&quot;headerlink&quot; title=&quot;文章摘要：通过阅读Vue源码来深入学习Vue，本文章主要介绍Vue的数据驱动部分源码。&quot;&gt;&lt;/a&gt;文章摘要：通过阅读Vue源码来深入学习Vue，本文章主要介绍Vue的数据驱动部分源码。&lt;/h5&gt;</summary>
    
    
    
    
    <category term="Vue" scheme="https://jrr997.github.io/blog/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>这是一段很长很长很长很长很长很长很长很长很长很长的文字，用来测试一下标题</title>
    <link href="https://jrr997.github.io/blog/2021/02/18/test/"/>
    <id>https://jrr997.github.io/blog/2021/02/18/test/</id>
    <published>2021-02-17T16:26:21.000Z</published>
    <updated>2021-02-17T16:30:31.149Z</updated>
    
    <content type="html"><![CDATA[<h5 id="测试。"><a href="#测试。" class="headerlink" title="测试。"></a>测试。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;测试。&quot;&gt;&lt;a href=&quot;#测试。&quot; class=&quot;headerlink&quot; title=&quot;测试。&quot;&gt;&lt;/a&gt;测试。&lt;/h5&gt;</summary>
      
    
    
    
    <category term="博客" scheme="https://jrr997.github.io/blog/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客" scheme="https://jrr997.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>记录博客建站完成</title>
    <link href="https://jrr997.github.io/blog/2021/02/17/My-New-Post/"/>
    <id>https://jrr997.github.io/blog/2021/02/17/My-New-Post/</id>
    <published>2021-02-17T10:43:02.000Z</published>
    <updated>2021-02-17T16:28:45.569Z</updated>
    
    <content type="html"><![CDATA[<h5 id="文章摘要：记录博客建立完成及过程中遇到的坑"><a href="#文章摘要：记录博客建立完成及过程中遇到的坑" class="headerlink" title="文章摘要：记录博客建立完成及过程中遇到的坑"></a>文章摘要：记录博客建立完成及过程中遇到的坑<a id="more"></a></h5><h5 id="emsp-emsp-记录一下自己的博客顺利建成！"><a href="#emsp-emsp-记录一下自己的博客顺利建成！" class="headerlink" title="  记录一下自己的博客顺利建成！"></a>  记录一下自己的博客顺利建成！<br></h5><h5 id="emsp-emsp-本以为用HEXO建个博客挺容易的，结果还是踩了很多坑，不过最终还是顺利完成这个博客。"><a href="#emsp-emsp-本以为用HEXO建个博客挺容易的，结果还是踩了很多坑，不过最终还是顺利完成这个博客。" class="headerlink" title="  本以为用HEXO建个博客挺容易的，结果还是踩了很多坑，不过最终还是顺利完成这个博客。"></a>  本以为用HEXO建个博客挺容易的，结果还是踩了很多坑，不过最终还是顺利完成这个博客。<br></h5><h5 id="emsp-emsp-顺便记录一下这些坑吧。"><a href="#emsp-emsp-顺便记录一下这些坑吧。" class="headerlink" title="  顺便记录一下这些坑吧。"></a>  顺便记录一下这些坑吧。<br></h5><h5 id="第一个大坑"><a href="#第一个大坑" class="headerlink" title="第一个大坑:"></a>第一个大坑:<br></h5><h5 id="emsp-emsp-首先是博客主题的作者使用ejs来写的，按照主题的文档步骤来还是会报错，错误是-is-not-defined-in-XXX…，这里应该是这个博客最麻烦的地方，我并不知道这个-代表的是什么。"><a href="#emsp-emsp-首先是博客主题的作者使用ejs来写的，按照主题的文档步骤来还是会报错，错误是-is-not-defined-in-XXX…，这里应该是这个博客最麻烦的地方，我并不知道这个-代表的是什么。" class="headerlink" title="  首先是博客主题的作者使用ejs来写的，按照主题的文档步骤来还是会报错，错误是_ is not defined in XXX…，这里应该是这个博客最麻烦的地方，我并不知道这个_代表的是什么。"></a>  首先是博客主题的作者使用ejs来写的，按照主题的文档步骤来还是会报错，错误是_ is not defined in XXX…，这里应该是这个博客最麻烦的地方，我并不知道这个_代表的是什么。<br></h5><h5 id="emsp-emsp-后来据我观察，作者在三个地方都用到-XX方法，且三个地方只要执行了就会报错，其中作者用到了-template和-isArray-。"><a href="#emsp-emsp-后来据我观察，作者在三个地方都用到-XX方法，且三个地方只要执行了就会报错，其中作者用到了-template和-isArray-。" class="headerlink" title="  后来据我观察，作者在三个地方都用到 _.XX方法，且三个地方只要执行了就会报错，其中作者用到了_.template和_.isArray()。"></a>  后来据我观察，作者在三个地方都用到 _.XX方法，且三个地方只要执行了就会报错，其中作者用到了_.template和_.isArray()。<br></h5><h5 id="emsp-emsp-我盲猜作者是在ejs中使用了jquery，而这个-就是-的另外写法，但是我在往上并找不到相关的资料-VPN碰巧今晚过期了，因此可能没找详细。"><a href="#emsp-emsp-我盲猜作者是在ejs中使用了jquery，而这个-就是-的另外写法，但是我在往上并找不到相关的资料-VPN碰巧今晚过期了，因此可能没找详细。" class="headerlink" title="  我盲猜作者是在ejs中使用了jquery，而这个_就是$的另外写法，但是我在往上并找不到相关的资料(VPN碰巧今晚过期了，因此可能没找详细。)"></a>  我盲猜作者是在ejs中使用了jquery，而这个_就是$的另外写法，但是我在往上并找不到相关的资料(VPN碰巧今晚过期了，因此可能没找详细。)<br></h5><h5 id="emsp-emsp-我也不想在这个地方纠结了，于是只能将计就计，把有-的地方都删掉，或者用顺着思路其他方法代替，终于博客没报错并且能运行。"><a href="#emsp-emsp-我也不想在这个地方纠结了，于是只能将计就计，把有-的地方都删掉，或者用顺着思路其他方法代替，终于博客没报错并且能运行。" class="headerlink" title="  我也不想在这个地方纠结了，于是只能将计就计，把有_的地方都删掉，或者用顺着思路其他方法代替，终于博客没报错并且能运行。"></a>  我也不想在这个地方纠结了，于是只能将计就计，把有_的地方都删掉，或者用顺着思路其他方法代替，终于博客没报错并且能运行。<br><br></h5><h5 id="第二个大坑"><a href="#第二个大坑" class="headerlink" title="第二个大坑:"></a>第二个大坑:<br></h5><h5 id="emsp-emsp-点击阅读全文后，并没有显示内容，其中有部分原因是因为这个-，不过解决后还是没显示内容。但是审查元素发现其实内容是有的，这就让我怀疑是display-none，搞的鬼，但事实并不是这样。"><a href="#emsp-emsp-点击阅读全文后，并没有显示内容，其中有部分原因是因为这个-，不过解决后还是没显示内容。但是审查元素发现其实内容是有的，这就让我怀疑是display-none，搞的鬼，但事实并不是这样。" class="headerlink" title="  点击阅读全文后，并没有显示内容，其中有部分原因是因为这个__，不过解决后还是没显示内容。但是审查元素发现其实内容是有的，这就让我怀疑是display:none，搞的鬼，但事实并不是这样。"></a>  点击阅读全文后，并没有显示内容，其中有部分原因是因为这个__，不过解决后还是没显示内容。但是审查元素发现其实内容是有的，这就让我怀疑是display:none，搞的鬼，但事实并不是这样。<br></h5><h5 id="emsp-emsp-后来我改变浏览器窗口大小，当浏览器窗口宽度小于480px时居然显示出了内容，而且还是有动画的，然后我以为是动画的问题，于是往JS的方向找，结果被打脸了——找不到。"><a href="#emsp-emsp-后来我改变浏览器窗口大小，当浏览器窗口宽度小于480px时居然显示出了内容，而且还是有动画的，然后我以为是动画的问题，于是往JS的方向找，结果被打脸了——找不到。" class="headerlink" title="  后来我改变浏览器窗口大小，当浏览器窗口宽度小于480px时居然显示出了内容，而且还是有动画的，然后我以为是动画的问题，于是往JS的方向找，结果被打脸了——找不到。"></a>  后来我改变浏览器窗口大小，当浏览器窗口宽度小于480px时居然显示出了内容，而且还是有动画的，然后我以为是动画的问题，于是往JS的方向找，结果被打脸了——找不到。<br></h5><h5 id="emsp-emsp-那只剩下一个可能了——css的媒体查询。作者是通过opacity来隐藏页面的，我也不知道他为什么要隐藏，我把内容的opacity改成1就能一直显示了。"><a href="#emsp-emsp-那只剩下一个可能了——css的媒体查询。作者是通过opacity来隐藏页面的，我也不知道他为什么要隐藏，我把内容的opacity改成1就能一直显示了。" class="headerlink" title="  那只剩下一个可能了——css的媒体查询。作者是通过opacity来隐藏页面的，我也不知道他为什么要隐藏，我把内容的opacity改成1就能一直显示了。"></a>  那只剩下一个可能了——css的媒体查询。作者是通过opacity来隐藏页面的，我也不知道他为什么要隐藏，我把内容的opacity改成1就能一直显示了。</h5><h5 id="emsp-emsp-其实这个博客很多功能还不完善，后续我会接着更新。"><a href="#emsp-emsp-其实这个博客很多功能还不完善，后续我会接着更新。" class="headerlink" title="  其实这个博客很多功能还不完善，后续我会接着更新。"></a>  其实这个博客很多功能还不完善，后续我会接着更新。</h5><h5 id="emsp-emsp-最后祝贺自己成功搭建这个博客。"><a href="#emsp-emsp-最后祝贺自己成功搭建这个博客。" class="headerlink" title="  最后祝贺自己成功搭建这个博客。"></a>  最后祝贺自己成功搭建这个博客。</h5>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;文章摘要：记录博客建立完成及过程中遇到的坑&quot;&gt;&lt;a href=&quot;#文章摘要：记录博客建立完成及过程中遇到的坑&quot; class=&quot;headerlink&quot; title=&quot;文章摘要：记录博客建立完成及过程中遇到的坑&quot;&gt;&lt;/a&gt;文章摘要：记录博客建立完成及过程中遇到的坑&lt;/h5&gt;</summary>
    
    
    
    <category term="博客" scheme="https://jrr997.github.io/blog/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客" scheme="https://jrr997.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
