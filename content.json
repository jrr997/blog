[{"title":"vue src readding-4","date":"2021-02-27T14:05:49.000Z","path":"2021/02/27/vue-src-readding-4/","text":"简介：编译的过程就是把模板变成render函数. Vue.js 提供了 2 个版本，一个是 Runtime + Compiler 的，一个是 Runtime only 的，前者是包含编译代码的，可以把编译过程放在运行时做，后者是不包含编译代码的，需要借助 webpack 的 vue-loader 事先把模板编译成 render函数。 编译过程vue的编译过程主要分为三步： 解析模板字符串生成AST 1const ast = parse(template.trim(), options) 优化语法树 1optimize(ast, options) 生成代码 1const code = generate(ast, options) parse什么是ASTAST是抽象语法树，它具体是这样的： 123&lt;ul :class=\"bindCls\" class=\"list\" v-if=\"isShow\"&gt; &lt;li v-for=\"(item,index) in data\" @click=\"clickItem(index)\"&gt;{{item}}:{{index}}&lt;/li&gt;&lt;/ul&gt; 经过 parse 过程后，生成的 AST 如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152ast = { 'type': 1, 'tag': 'ul', 'attrsList': [], 'attrsMap': { ':class': 'bindCls', 'class': 'list', 'v-if': 'isShow' }, 'if': 'isShow', 'ifConditions': [{ 'exp': 'isShow', 'block': // ul ast element }], 'parent': undefined, 'plain': false, 'staticClass': 'list', 'classBinding': 'bindCls', 'children': [{ 'type': 1, 'tag': 'li', 'attrsList': [{ 'name': '@click', 'value': 'clickItem(index)' }], 'attrsMap': { '@click': 'clickItem(index)', 'v-for': '(item,index) in data' }, 'parent': // ul ast element 'plain': false, 'events': { 'click': { 'value': 'clickItem(index)' } }, 'hasBindings': true, 'for': 'data', 'alias': 'item', 'iterator1': 'index', 'children': [ 'type': 2, 'expression': '_s(item)+\":\"+_s(index)' 'text': '{{item}}:{{index}}', 'tokens': [ {'@binding':'item'}, ':', {'@binding':'index'} ] ] }]} 如何生成AST？主要通过正则匹配来解析模板，流程图如下： optimize（优化AST）为什么要优化AST？因为Vue是数据驱动、响应式的，但是我们的模板并不是所有数据都是响应式的，也有很多数据是首次渲染后就永远不会变化的，那么这部分数据生成的 DOM 也不会变化，我们可以在 patch 的过程跳过对他们的比对。 如何进行优化？optimize 的过程，就是深度遍历这个 AST 树，去检测它的每一颗子树是不是静态节点，如果是静态节点则它们生成 DOM 永远不需要改变，这对运行时对模板的更新起到极大的优化作用。 我们通过 optimize 我们把整个 AST 树中的每一个 AST 元素节点标记了 static 和 staticRoot，它会影响我们接下来执行代码生成的过程。 generate这里就是把经过优化的AST转化为render函数。","tags":[{"name":"Vue","slug":"Vue","permalink":"https://jrr997.github.io/blog/tags/Vue/"}]},{"title":"Vue源码阅读(3)之响应式原理","date":"2021-02-22T11:25:28.000Z","path":"2021/02/22/vue-src-readding-3/","text":"简介本篇文章属于新手向，着重点在理解Vue响应式系统中的Observer、Dep、Watcher,这是理解响应式源码的关键。因此这篇文章不会在分析源码上花很多功夫。 Object.defineProperty我们都知道Vue的响应式原理是通过Object.defineProperty修改get和set方法来实现的，当我们访问一个变量时就会执行get方法，当我们修改一个变量时会执行set方法。为了实现响应式，我们可以在get方法中收集依赖，这样就能知道哪些数据依赖当前数据。当数据发生变化时，set方法通知依赖者(watcher)进行数据更新。 Observer就是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新。 在介绍observer前，先要了解initState()的过程。 initState在new Vue时，会执行_init方法进行初始化，当中有一个initState方法，主要是对 props、methods、data、computed 和 wathcer 等属性做了初始化操作。这里我们重点分析 props 和 data。 initProps 遍历所有props，调用 defineReactive 方法把每个 prop 对应的值变成响应式。 通过 proxy 把 vm._props.xxx 的访问代理到 vm.xxx 上。 initData 调用 observe 方法观测整个 data 的变化，把 data 也变成响应式。 通过 proxy 把每一个值 vm._data.xxx 都代理到 vm.xxx 上。 这里涉及三个陌生的方法：proxy 、observe和defineReactive，下面分别介绍。 proxy： 123456789export function proxy (target: Object, sourceKey: string, key: string) { sharedPropertyDefinition.get = function proxyGetter () { return this[sourceKey][key] } sharedPropertyDefinition.set = function proxySetter (val) { this[sourceKey][key] = val } Object.defineProperty(target, key, sharedPropertyDefinition)} 简单来讲，创建一个vm.xxx属性，当我们访问和修改这个属性时，其实是在访问和修改vm._data.xxx，这是就是为什么我们能够通过this来访问到data和props。 observe： observe 方法的作用就是给非 VNode 的对象类型数据添加一个 Observer，如果已经添加过则直接返回，否则在满足一定条件下去实例化一个 Observer 对象实例，Observer等一会介绍。 defineReactive： defineReactive 的功能就是定义一个响应式对象，给对象动态添加 getter 和 setter，它的定义在 src/core/observer/index.js 中。 步骤： new Dep()。 拿到 obj 的属性描述符，然后对子对象递归调用 observe 方法。 ObserverObserver步骤： new Dep()。 执行 def 函数把自身实例添加到数据对象 value 的 __ob__ 属性上。 对数据value进行判断，如果是数组则遍历调用observe方法，如果是对象则调用 walk 方法，而 walk 方法是遍历对象的 key 调用 defineReactive 方法，那么我们来看一下这个方法是做什么的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Observer class that is attached to each observed * object. Once attached, the observer converts the target * object's property keys into getter/setters that * collect dependencies and dispatch updates. */export class Observer { value: any; dep: Dep; vmCount: number; // number of vms that has this object as root $data constructor (value: any) { this.value = value this.dep = new Dep() this.vmCount = 0 def(value, '__ob__', this) if (Array.isArray(value)) { const augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) this.observeArray(value) } else { this.walk(value) } } /** * Walk through each property and convert them into * getter/setters. This method should only be called when * value type is Object. */ walk (obj: Object) { const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) { defineReactive(obj, keys[i]) } } /** * Observe a list of Array items. */ observeArray (items: Array&lt;any&gt;) { for (let i = 0, l = items.length; i &lt; l; i++) { observe(items[i]) } }} 依赖收集Dep12345678910111213141516171819202122232425262728293031323334export default class Dep { static target: ?Watcher; // 静态属性target(Watcher类型) id: number; subs: Array&lt;Watcher&gt;; // 一个（Watcher类型）数组 constructor () { this.id = uid++ this.subs = [] } addSub (sub: Watcher) { /* 为后续数据变化时候能通知到哪些 subs 做准备 */ this.subs.push(sub) } removeSub (sub: Watcher) { remove(this.subs, sub) } depend () { if (Dep.target) { Dep.target.addDep(this) } } notify () { /* 所有Watcher的实例对象 */ const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) { subs[i].update() } }} 什么是依赖？ 123&lt;div&gt; &lt;p&gt;{{message}}&lt;/p&gt;&lt;/div&gt; 12345data: { text: 'hello world', message: 'hello vue',} 12345watch: { message: function (val, oldVal) { console.log('new: %s, old: %s', val, oldVal) },} 12345computed: { messageT() { return this.message + '!'; }} 这里可以看到，虽然data中有text和message，但只有message被使用了，因此只有message需要收集依赖。 Dep如何收集依赖? 在getter中收集，当数据被访问时调用dep.depend。 什么是依赖？ 其实就是watcher。 Watcher1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465export default class Watcher { vm: Component; deep: boolean; sync: boolean; deps: Array&lt;Dep&gt;; newDeps: Array&lt;Dep&gt;; depIds: SimpleSet; newDepIds: SimpleSet; before: ?Function; getter: Function; value: any; constructor ( vm: Component, expOrFn: string | Function, cb: Function, options?: ?Object, isRenderWatcher?: boolean ) { this.vm = vm vm._watchers.push(this) /* 监听器的options */ if (options) { this.deep = !!options.deep // 深度监听 // ... this.sync = !!options.sync // 在当前 Tick 中同步执行 watcher 的回调函数，否则响应式数据发生变化之后，watcher回调会在nextTick后执行； } /* Watcher实例持有Dep的实例的数组 */ this.deps = [] // 老的Dep集合 this.newDeps = [] // 触发更新生成的新的Dep集合 this.depIds = new Set() this.newDepIds = new Set() get () { /* 收集Watcher实例,也就是Dep.target */ pushTarget(this) let value const vm = this.vm try { /* this.getter对应就是我们上篇讲到的vm._update(vm._render(), hydrating),_update会生成VNode,在这个过程中会访 问vm上的data，这时候就触发了数据对象的getter，defineReactive中可以发现每个getter都持有一个dep, 因此在触发getter的时候会触发Dep的depend方法，也就触发了Watcher的addDep方法 */ value = this.getter.call(vm, vm) } finally { /* 把 Dep.target 恢复成上一个状态，因为当前 vm 的数据依赖收集已经完成，那么对应的渲染Dep.target 也需要改变 */ popTarget() this.cleanupDeps() } return value } addDep (dep: Dep) { const id = dep.id /* 保证同一数据不会被添加多次 */ if (!this.newDepIds.has(id)) { this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) { /* 把当前的 watcher 订阅到这个数据持有的 dep 的 subs, 目的是为后续数据变化时候能通知到哪些 subs 做准备 */ dep.addSub(this) } } }} watcher中有两个方法: addDep:看看自己依赖谁，然后告诉被依赖者，让自己进入被依赖者的sub名单。这样当被依赖者发生改变时就通知自己更新。 update:当自己需要更新时调用，这个方法会在数据更新后渲染到页面上，并且调用update这个声明周期函数。 总结回顾一下，Vue响应式原理的核心就是Observer、Dep、Watcher。 Observer中进行响应式的绑定，在数据被读的时候，触发get方法，执行Dep来收集依赖，也就是收集Watcher。 在数据被改的时候，触发set方法，通过对应的所有依赖(Watcher)，去执行更新。比如watch和computed就执行开发者自定义的回调方法。 本文参考了https://juejin.cn/post/6844903858850758670#heading-1。","tags":[{"name":"Vue","slug":"Vue","permalink":"https://jrr997.github.io/blog/tags/Vue/"}]},{"title":"Vue源码阅读(2)之组件化","date":"2021-02-21T13:28:51.000Z","path":"2021/02/21/Vue-src-readding-2/","text":"简介组件化是Vue的一个核心思想。所谓组件化，就是把页面拆分成多个组件 (component)，每个组件依赖的 CSS、JavaScript、模板、图片等资源放在一起开发和维护。组件是资源独立的，组件在系统内部可复用，组件和组件之间可以嵌套。 本文主要关注Vue如何创建组件。 createComponent在上一篇文章中介绍过vm._render方法，作用是根据render函数生成VDOM，生成VDOM主要是由vm_render方法中的createElement中的_createElement方法实现的。 _createElement中有一段逻辑是对参数 tag 的判断，如果是一个普通的 html 标签，如div，则会实例化一个普通 VNode 节点，否则通过 createComponent 方法创建一个组件 VNode。 createComponent有三个核心步骤： 构造子类构造函数 安装组件钩子函数 实例化 VNode 下面我会分别介绍这三个步骤。 构造子类构造函数123456const baseCtor = context.$options._base// plain options object: turn it into a constructorif (isObject(Ctor)) { Ctor = baseCtor.extend(Ctor)} 这里 baseCtor 实际上就是 Vue，这个的定义是在最开始初始化 Vue 的阶段，在 src/core/global-api/index.js 中的 initGlobalAPI 函数有这么一段逻辑： 123// this is used to identify the \"base\" constructor to extend all plain-object// components with in Weex's multi-instance scenarios.Vue.options._base = Vue 我们可以注意到context.$options._base和Vue.options._base，前者是实例中取出_base，后者是构造函数中取出_base,那么为什么这两个地方都能取出_base呢？ 实际上在 src/core/instance/init.js 里 Vue 原型上的 _init 函数中有这么一段逻辑： 12345vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || {}, vm) 这样就把 Vue 上的一些 option 扩展到了 vm.$options 上，意思是vm(组件)的options中包含了Vue的options和用户传入的options。 回到Ctor = baseCtor.extend(Ctor)，这里Ctor是Vue的子类，继承了Vue的属性和方法，extend返回的是一个叫Sub的组件构造函数。当我们去实例化Sub时，就会执行 this._init 逻辑再次走到了 Vue 实例的初始化逻辑，这意味着组件的实例化和Vue的实例化相类似。 安装钩子函数12// install component management hooks onto the placeholder nodeinstallComponentHooks(data) 整个 installComponentHooks 的过程就是把 componentVNodeHooks 的钩子函数合并到 data.hook 中，在 VNode 执行 patch 的过程中执行相关的钩子函数。 简单地说是把生成VNode的方法都准备好，准备生成Vnode。 # 实例化VNode12345678const name = Ctor.options.name || tagconst vnode = new VNode( `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`, data, undefined, undefined, undefined, context, { Ctor, propsData, listeners, tag, children }, asyncFactory)return vnode 最后一步非常简单，通过 new VNode 实例化一个 vnode 并返回。需要注意的是和普通元素节点的 vnode 不同，组件的 vnode 是没有 children 的，这点很关键，在之后的 patch 过程中我们会再提。 总结创建一个组件经历了三个步骤： 创建组件的构造函数 执行构造函数，准备好生成Vnode的相关方法。 生成Vnode。 下图是组件创建过程的函数调用栈，通过调用栈我们也能更好地了解组件的创建过程。 Download组件创建过程.png 由下往上看，跟着函数调用栈的顺序，可以看出整个过程是 执行 new Vue，然后初始化 vm 实例，扩展原型方法 执行 mount 函数去解析编译 template 模板 执行 Watcher render 去生成 VNode tree 执行 update 中的 patch 去生成 DOM，如遇到组件 初始化 Sub 构造器 执行 new Sub，初始化组件 vm 实例，扩展原型方法 执行 mount 函数解析编译组件模板，生成组件 VNode tree，最终返回组件 DOM 如再遇组件，则继续递归 可以看出 Vue 的组件生成顺序是由子到父的。 Patch既然有了VNode，下一步应该是调用vm._update来创建真实DOM，这个过程就是patch。 具体的过程就不细说，这里主要注意一个组件中可能又包含另外的组件。如果组件 patch 过程中又创建了子组件，那么DOM 的插入顺序是先子后父。 组件注册全局注册相当于在Vue.options.components注册了一个组件。因为局部组件都会通过Vue.extend创建一个Sub子类(前面介绍过)，而Sub会继承Vue.options.components，这里是通过mergeOptions实现的，前面也简单提到过。 到这里，局部组件就能通过options拿到全局组件。 局部注册Vue.js 也同样支持局部注册，我们可以在一个组件内部使用 components 选项做组件的局部注册，例如： 1234567import HelloWorld from './components/HelloWorld'export default { components: { HelloWorld }} 其实理解了全局注册的过程，局部注册是非常简单的。在组件的 Vue 的实例化阶段有一个合并 option 的逻辑，之前我们也分析过，所以就把 components 合并到 vm.$options.components 上，这样我们就可以在 resolveAsset 的时候拿到这个组件的构造函数，并作为 createComponent 的钩子的参数。 注意，局部注册和全局注册不同的是，只有该类型的组件才可以访问局部注册的子组件，而全局注册是扩展到 Vue.options 下，所以在所有组件创建的过程中，都会从全局的 Vue.options.components 扩展到当前组件的 vm.$options.components 下，这就是全局注册的组件能被任意使用的原因。 异步组件因为我在实战中并没有用过异步组件，这里就先留个坑，只是简单的了解一下异步组件的作用。 在我们平时的开发工作中，为了减少首屏代码体积，往往会把一些非首屏的组件设计成异步组件，按需加载。Vue 也原生支持了异步组件的能力，如下： 123456Vue.component('async-example', function (resolve, reject) { // 这个特殊的 require 语法告诉 webpack // 自动将编译后的代码分割成不同的块， // 这些块将通过 Ajax 请求自动下载。 require(['./my-async-component'], resolve)}) 生命周期生命周期是一个很重要的知识点，我要单独开一篇文章来讲。","tags":[{"name":"Vue","slug":"Vue","permalink":"https://jrr997.github.io/blog/tags/Vue/"}]},{"title":"Vue源码阅读(1)之数据驱动","date":"2021-02-20T15:58:19.000Z","path":"2021/02/20/vue-src-readding-1/","text":"文章摘要：通过阅读Vue源码来深入学习Vue，本文章主要介绍Vue的数据驱动部分源码。作为学习者，这篇文章主要是参考https://ustbhuangyi.github.io/vue-analysis/v2/prepare/ Vue源码阅读一、vue的源码目录设计1234567src├── compiler # 编译相关 ├── core # 核心代码 ├── platforms # 不同平台的支持├── server # 服务端渲染├── sfc # .vue 文件解析├── shared # 共享代码 compilercompiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。 corecore 目录包含了 Vue.js 的核心代码，包括内置组件、全局 API 封装，Vue 实例化、观察者、虚拟 DOM、工具函数等等。 Vue入口Vue入口在 1src/core/instance/index.js 1234567891011121314151617181920212223import { initMixin } from './init'import { stateMixin } from './state'import { renderMixin } from './render'import { eventsMixin } from './events'import { lifecycleMixin } from './lifecycle'import { warn } from '../util/index'function Vue (options) { if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) { warn('Vue is a constructor and should be called with the `new` keyword') } this._init(options)}initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue 这里可以看出Vue是一个构造函数。我们可以看到Vue被传入很多xxxMixin 函数中，这些函数的作用是给Vue.prototype扩展方法。 initGlobalAPI Vue.js 在整个初始化过程中，除了给它的原型 prototype 上扩展方法，还会给 Vue 这个对象本身扩展全局的静态方法，它的定义在 src/core/global-api/index.js 中，全局方法包括set、delete、nextTick等。 二、数据驱动Vue.js 一个核心思想是数据驱动。数据驱动是指数据驱动视图的生成，我们只用修改数据，视图就会发生相应的修改，免去操作DOM来修改视图的步骤。 new Vue 发生了什么？12345678function Vue (options) { if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) { warn('Vue is a constructor and should be called with the `new` keyword') } this._init(options)} 从这里可见，new Vue后执行了this._init方法，并传入了options，而this_init方法主要做了这些事情：合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher 等等。下面是this._init的部分代码。 12345678910111213141516/* istanbul ignore else */ if (process.env.NODE_ENV !== 'production') { initProxy(vm) } else { vm._renderProxy = vm } // expose real self vm._self = vm initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, 'beforeCreate') initInjections(vm) // resolve injections before data/props initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, 'created') 在beforeCreate前，Vue已经初始化了生命周期、时间和渲染，在beforeCreate和created之间有一个initState方法，initState主要是初始化data、props等属性。意思是beforeCreate不能拿到data、props、methods、computed等，要在created中拿。 Vue实例的挂载compiler 版本的 $mount 实现非常有意思，先来看一下 src/platform/web/entry-runtime-with-compiler.js 文件中定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const mount = Vue.prototype.$mountVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component { el = el &amp;&amp; query(el) /* istanbul ignore if */ if (el === document.body || el === document.documentElement) { process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.` ) return this } const options = this.$options // resolve template/el and convert to render function if (!options.render) { let template = options.template if (template) { if (typeof template === 'string') { if (template.charAt(0) === '#') { template = idToTemplate(template) /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; !template) { warn( `Template element not found or is empty: ${options.template}`, this ) } } } else if (template.nodeType) { template = template.innerHTML } else { if (process.env.NODE_ENV !== 'production') { warn('invalid template option:' + template, this) } return this } } else if (el) { template = getOuterHTML(el) } if (template) { /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { mark('compile') } const { render, staticRenderFns } = compileToFunctions(template, { shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments }, this) options.render = render options.staticRenderFns = staticRenderFns /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { mark('compile end') measure(`vue ${this._name} compile`, 'compile', 'compile end') } } } return mount.call(this, el, hydrating)} 在runtime-with-compiler版本的代码中，const mount = Vue.prototype.$mount缓存了runtime-only的$mount，然后重写了$mount方法，这个重写的$mount方法主要做了两件事情： 第一步：Vue实例通过$mount 来挂载vm，且$mount 限制Vue实例不能挂载到body和html根节点上。 第二步：把el和template字符串转化为render方法。Vue 2.0 版本中，所有 Vue 的组件的渲染最终都需要 render 方法。 做完这两步之后，会执行之前缓存的runtime-only的$mount。这个挂载是真正的挂载。 12345678// public mount methodVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component { el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)} 原先的$mount 方法实际上会去调用 mountComponent 方法，这个方法定义在 src/core/instance/lifecycle.js 文件中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273export function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean): Component { vm.$el = el if (!vm.$options.render) { vm.$options.render = createEmptyVNode if (process.env.NODE_ENV !== 'production') { /* istanbul ignore if */ if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== '#') || vm.$options.el || el) { warn( 'You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm ) } else { warn( 'Failed to mount component: template or render function not defined.', vm ) } } } callHook(vm, 'beforeMount') let updateComponent /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { updateComponent = () =&gt; { const name = vm._name const id = vm._uid const startTag = `vue-perf-start:${id}` const endTag = `vue-perf-end:${id}` mark(startTag) const vnode = vm._render() mark(endTag) measure(`vue ${name} render`, startTag, endTag) mark(startTag) vm._update(vnode, hydrating) mark(endTag) measure(`vue ${name} patch`, startTag, endTag) } } else { updateComponent = () =&gt; { vm._update(vm._render(), hydrating) } } // we set this to vm._watcher inside the watcher's constructor // since the watcher's initial patch may call $forceUpdate (e.g. inside child // component's mounted hook), which relies on vm._watcher being already defined new Watcher(vm, updateComponent, noop, { before () { if (vm._isMounted) { callHook(vm, 'beforeUpdate') } } }, true /* isRenderWatcher */) hydrating = false // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook if (vm.$vnode == null) { vm._isMounted = true callHook(vm, 'mounted') } return vm} 这段代码说明了mountComponent做了两件事情： 调用 vm._render生成了VNode，最终调用 vm._update 更新 DOM。 创建Watcher实例，而watcher做又做了两件事情： 一个是初始化的时候会执行回调函数callHook(vm, 'mounted') 二是当vm 实例中的监测的数据发生变化的时候执行回调函数```callHook(vm, ‘beforeUpdate’)`` 总结 模板转化成render函数。 vm._render生成了VNode。 callHook(vm, 'beforeUpdate') vm._update 更新 DOM。 callHook(vm, 'mounted')或者callHook(vm, 'beforeUpdate') vm._render前面提到vm._render,这个方法的作用就是把render函数生成VNode，也就是虚拟DOM。 模板： 123&lt;div id=\"app\"&gt; {{ message }}&lt;/div&gt; 模板转为render函数： 1234567render: function (createElement) { return createElement('div', { attrs: { id: 'app' }, }, this.message)} vm._render方法传入render函数，生成VNode，这里的$createElement就是创建VNode的方法。 1vnode = render.call(vm._renderProxy, vm.$createElement) Virtual DOM首先必须知道为什么需要虚拟DOM？ 因为浏览器的DOM是十分“昂贵”的，真实DOM十分庞大，每个真实DOM都有很多属性和方法。如果我们频繁地更新真实DOM，可能会出现性能问题，因此虚拟DOM就出现了。 那么什么是虚拟DOM？ 虚拟DOM就是描述真实DOM的JS对象，与真实DOM对比起来，虚拟DOM是轻量的。它的核心定义无非就几个关键属性，标签名、数据、子节点、键值等。 虚拟DOM除了它的数据结构的定义，映射到真实的 DOM 实际上要经历 VNode 的 create、diff、patch 等过程。那么在 Vue.js 中，VNode 的 create 是通过之前提到的 createElement 方法创建的，我们接下来分析这部分的实现。 createElementcreateElement做两件事情 children 的规范化 由于 Virtual DOM 实际上是一个树状结构，每一个 VNode 可能会有若干个子节点，这些子节点应该也是 VNode 的类型。_createElement 接收的第 4 个参数 children 是任意类型的，因此我们需要把它们规范成 VNode 类型。 在大多数情况下children都是VNode类型的，但也有例外就是 functional component 函数式组件返回的是一个数组而不是一个根节点，所以会通过 Array.prototype.concat 方法把整个 children 数组打平，让它的深度只有一层。 VNode 的创建 单节点就直接创建一个VNode。 如果是多个节点，会用数组表示，遍历创建VNode。 有时候数组中会嵌套数组，这时用递归。 经过这两个步骤就形成了一个 VNode Tree。 回到 mountComponent 函数的过程，我们已经知道 vm._render 是如何创建了一个 VNode，接下来就是要把这个 VNode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过 vm._update 完成的，接下来分析一下这个过程。 vm._updateVue 的 _update 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候；由于我们这一章节只分析首次渲染部分，数据更新部分会在之后分析响应式原理的时候涉及。_update 方法的作用是把 VNode 渲染成真实的 DOM，它的定义在 src/core/instance/lifecycle.js 中。 首次渲染时vm._update的主要是调用一个patch方法 12// initial rendervm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) 其中patch方法又有一个creatElm方法，作用是根据虚拟DOM创建真实DOM。 简单地讲，在首次渲染时，_update方法根据虚拟DOM数创建一个真实的DOM树然后插入到vm.$el上。 总结那么至此我们从主线上把模板和数据如何渲染成最终的 DOM 的过程分析完毕了，我们可以通过下图更直观地看到从初始化 Vue 到最终渲染的整个过程。 img","tags":[{"name":"Vue","slug":"Vue","permalink":"https://jrr997.github.io/blog/tags/Vue/"}]},{"title":"这是一段很长很长很长很长很长很长很长很长很长很长的文字，用来测试一下标题","date":"2021-02-17T16:26:21.000Z","path":"2021/02/18/test/","text":"测试。","tags":[{"name":"博客","slug":"博客","permalink":"https://jrr997.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"记录博客建站完成","date":"2021-02-17T10:43:02.000Z","path":"2021/02/17/My-New-Post/","text":"文章摘要：记录博客建立完成及过程中遇到的坑 记录一下自己的博客顺利建成！ 本以为用HEXO建个博客挺容易的，结果还是踩了很多坑，不过最终还是顺利完成这个博客。 顺便记录一下这些坑吧。第一个大坑: 首先是博客主题的作者使用ejs来写的，按照主题的文档步骤来还是会报错，错误是_ is not defined in XXX…，这里应该是这个博客最麻烦的地方，我并不知道这个_代表的是什么。 后来据我观察，作者在三个地方都用到 _.XX方法，且三个地方只要执行了就会报错，其中作者用到了_.template和_.isArray()。 我盲猜作者是在ejs中使用了jquery，而这个_就是$的另外写法，但是我在往上并找不到相关的资料(VPN碰巧今晚过期了，因此可能没找详细。) 我也不想在这个地方纠结了，于是只能将计就计，把有_的地方都删掉，或者用顺着思路其他方法代替，终于博客没报错并且能运行。第二个大坑: 点击阅读全文后，并没有显示内容，其中有部分原因是因为这个__，不过解决后还是没显示内容。但是审查元素发现其实内容是有的，这就让我怀疑是display:none，搞的鬼，但事实并不是这样。 后来我改变浏览器窗口大小，当浏览器窗口宽度小于480px时居然显示出了内容，而且还是有动画的，然后我以为是动画的问题，于是往JS的方向找，结果被打脸了——找不到。 那只剩下一个可能了——css的媒体查询。作者是通过opacity来隐藏页面的，我也不知道他为什么要隐藏，我把内容的opacity改成1就能一直显示了。 其实这个博客很多功能还不完善，后续我会接着更新。 最后祝贺自己成功搭建这个博客。","tags":[{"name":"博客","slug":"博客","permalink":"https://jrr997.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]}]