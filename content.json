[{"title":"HTTP2","date":"2021-03-12T06:20:38.000Z","path":"2021/03/12/HTTP2/","text":"文章摘要：了解HTTP2的新特性HTTP2前言Q：为什么要HTTP2？ A：因为HTTP1.x有缺陷。 连接无法复用，一个TCP连接对应一个http请求。每次请求都要新建一个TCP连接，而TCP连接要经过三次握手和慢启动，效率较低。 HTTP1.0中，每个请求都要重新建立一个连接。 队头阻塞 HTTP1.1加入了keep-alive，虽然可以在同一个TCP连接中发送多个HTTP请求，但是在同一时间、同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞。这意味着某个请求的超时会导致后面的请求阻塞(线头阻塞)，HTTP1.1发送请求是单线程的。 头部开销大 在HTTP1.x，每次请求都会在header中携带大量的信息，而这些信息有很多都是重复的，这方面有很大的优化空间(HTTP2.0就优化了这方面)。 HTTP2旨在在HTTP1.x的基础上，改善web性能，可以认为是在HTTP1.x的基础上进行扩展。 那么HTTP2做了什么工作呢？ 一句话概括就是HTTP2的新特性：二进制分帧、多路复用、Header压缩、服务端推送。 1.二进制分帧这里有两个重要概念：二进制和分帧 二进制Q：为什么是二进制？ A：HTTP2采用二进制传输，而HTTP1.x传输的是文本，由于二进制只有0和1，因此数据解析起来更高效。 分帧Q1：什么是分帧？ A1：这里要先了解几个概念： 流：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（1、2…N）； 消息：相当于HTTP请求，由一个或多个帧组成; 帧：分为Header帧和Data帧，Header帧保存的是HTTP请求头部的信息，Data帧保存的是数据信息，包括请求参数和响应结果。帧是最小的传输单位，帧的首部会标识出当前帧所属的流，因为HTTP2把一个请求分为多个帧传输，那么如何区分某个帧是哪个请求呢？这个标志的流用以区分不同的HTTP请求。 总结一下：消息(初步理解为HTTP请求)在流中传输，而消息又拆分成多个帧用来传输。当然一个流可以传输多个信息，只要在帧的首部进行区分就行。 Q2：为什么要分帧？ A2：分帧主要用在多路复用中，解决HTTP1.x中数据传输阻塞的问题，下面有更具体的描述。 2.多路复用 双向传输：在同一个TCP连接中可以传输任意数量的双向数据流，这就突破了HTTP1.1对HTTP请求数量的限制。 一个TCP连接：同一域名下数据的传输在一个TCP连接中完成。在HTTP1.x中，一个网页可能会同时与服务器建立多个TCP连接来加快资源获取的速度，而在HTTP2不需要这么做。 帧乱序传输：注意HTTP2的数据传输时双向的，这意味着请求和响应可以在同一个TCP连接中同时传输。，数据可以乱序传输，因为每个数据帧都会记录了自己属于哪个请求以及自己的顺序，只要在数据传输的终点根据帧数据的提供信息把帧拼接起来，即可获取一个完整的请求。这么做的好处是解决了HTTP1.x中的阻塞问题。 并行传输：可以并行传输多个HTTP请求（多流）。在HTTP1.1时虽然有长连接和管道化，但长连接的同一时刻只有一个请求被发送，要实现并行请求，得多个TCP连接。 3.优先值HTTP2中每个请求都可以携带一个 31bit 的优先值，0 表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。 4.头部压缩文章的简介中提到过HTTP1.x中的请求头部开销大，有很大的优化空间，HTTP2就是用压缩策略(HPACK)来进行优化。 下面这张截图，取自 Google 的性能专家 Ilya Grigorik 在 Velocity 2015 • SC 会议中分享的「HTTP/2 is here, let’s optimize!」，非常直观地描述了 HTTP/2 中头部压缩的原理： hpack-header-compression 通俗地讲： 服务端和客户端在建立连接后共同维护一份静态字典(Static table)，字典中包含常见的头部名称，以及特别常见的头部名称与值的组合； 那么静态字典有什么用呢？ 我们可以看到字典中每个键值对都有索引值，如果我们发送的HTTP请求的头部信息和静态字典中的某一项完全匹配，那么我们用索引值就能代表某个请求头部信息，这样就大大缩小了头部信息的大小。 维护一份相同的动态字典（Dynamic Table），可以动态地添加内容； 如果请求的某一个头部信息在静态字典中匹配不到，那么我们需要把这个头部信息放进动态字典中并更新字典，那么以后我们就能继续用索引值来表示这个头部信息。 字典中的数据支持哈夫曼编码。 简单介绍一下哈夫曼编码： 哈夫曼编码(Huffman Coding)是一种编码方式，以哈夫曼树—即最优二叉树，带权路径长度最小的二叉树，经常应用于数据压缩。在计算机信息处理中，“哈夫曼编码”是一种一致性编码法（又称”熵编码法”），用于数据的无损耗压缩。这一术语是指使用一张特殊的编码表将源字符（例如某文件中的一个符号）进行编码。这张编码表的特殊之处在于，它是根据每一个源字符出现的估算概率而建立起来的（出现概率高的字符使用较短的编码，反之出现概率低的则使用较长的编码，这便使编码之后的字符串的平均期望长度降低，从而达到无损压缩数据的目的）。这种方法是由David.A.Huffman发展起来的。例如，在英文中，e的出现概率很高，而z的出现概率则最低。当利用哈夫曼编码对一篇英文进行压缩时，e极有可能用一个位(bit)来表示，而z则可能花去 25个位（不是26）。用普通的表示方法时，每个英文字母均占用一个字节（byte），即8个位。二者相比，e使用了一般编码的1/8的长度，z则使用了 3倍多。倘若我们能实现对于英文中各个字母出现概率的较准确的估算，就可以大幅度提高无损压缩的比例。 5.服务端推送当客户端向服务端请求一个HTML文件时，客户端很可能需要继续请求相关的CSS、JS文件。在HTTP2之前，客户端会在解析HTML时发现依赖的CSS、JS、图片等资源，然后向指定的地址来发送请求。 我们能从中发现问题：一是需要多轮HTTP请求，二是收到样式文件之前，网页都会显示一片空白，这个阶段一旦超过2秒，用户体验就会非常不好。 在HTTP2之前的解决方案： 一种解决办法就是把外部资源合并在网页文件里面，减少 HTTP 请求。比如，把样式表的内容写在&lt;style&gt;标签之中，把图片改成 Base64 编码的 Data URL。 另一种方法就是资源的预加载（preload）。网页预先告诉浏览器，立即下载某些资源。 这两种方法都有缺点。第一种方法虽然减少了 HTTP 请求，但是把不同类型的代码合并在一个文件里，违反了分工原则。第二种方法只是提前了下载时间，并没有减少 HTTP 请求。 HTTP2的服务端推送能解决这个问题。 什么是服务端推送？服务器推送（server push）指的是，还没有收到浏览器的请求，服务器就把各种资源推送给浏览器。 比如，浏览器只请求了index.html，但是服务器把index.html、style.css、example.png全部发送给浏览器。这样的话，只需要一轮 HTTP 通信，浏览器就得到了全部资源，提高了性能。 服务端推送的过程？PUSH_PROMISE 101 所有服务器推送数据流都由 PUSH_PROMISE 帧发起，表明了服务器向客户端推送所述资源的意图，并且需要先于请求推送资源的响应数据传输。 这种传输顺序非常重要: 客户端需要了解服务器打算推送哪些资源，以免为这些资源创建重复请求。 满足此要求的最简单策略是先于父响应（即，DATA 帧）发送所有 PUSH_PROMISE 帧，其中包含所承诺资源的 HTTP 标头。 在客户端接收到 PUSH_PROMISE 帧后，它可以根据自身情况选择拒绝数据流（通过 RST_STREAM 帧）。 （例如，如果资源已经位于缓存中，便可能会发生这种情况。） 这是一个相对于 HTTP/1.x 的重要提升。 相比之下，使用资源内联（一种受欢迎的 HTTP/1.x“优化”）等同于“强制推送”: 客户端无法选择拒绝、取消或单独处理内联的资源。 使用 HTTP/2，客户端仍然完全掌控服务器推送的使用方式。 客户端可以限制并行推送的数据流数量；调整初始的流控制窗口以控制在数据流首次打开时推送的数据量；或完全停用服务器推送。 这些优先级在 HTTP/2 连接开始时通过 SETTINGS 帧传输，可能随时更新。 推送的每个资源都是一个数据流，与内嵌资源不同，客户端可以对推送的资源逐一复用、设定优先级和处理。 浏览器强制执行的唯一安全限制是，推送的资源必须符合原点相同这一政策: 服务器对所提供内容必须具有权威性。 以上这段话其实说得不够深入。 Server push 的原理很简单，本质上就是先替你请求再告诉你。 假设服务端接收到客户端对 HTML 文件的请求，决定用 server push 推送一个样式表文件。那么，服务端会构造一个请求，包括请求方法和请求头，填充到一个 PUSH_PROMISE 帧里发送给客户端，来告知客户端它已经代劳发了这个请求。客户端可以根据 PUSH_PROMISE 帧里提供的 Promised Stream Id 来读推过去的响应。 img 当客户端收到这个 PUSH_PROMISE 帧的时候，它就知道服务端将要推送一个样式表文件回来。如果此时客户端需要请求这个样式表文件，即便服务端还没推完，它也不会往服务端发送对样式表文件的请求。 这里需要注意的是避免竞争。在上面的例子中，必须先发送 PUSH_PROMISE，再发送 HTML 的内容。这是因为 HTML 中存在对样式表文件的引用，一旦客户端发现了这个引用却还没收到 PUSH_PROMISE，它就会发起请求。这会引起 PUSH_PROMISE 和对样式表文件的请求之间的竞争，从而 server push 有一定的几率失败。 另一种竞争是不可避免的。如果客户端认为它不需要某个即将被推过来的资源（比如这个资源还在缓存的有效期内），那么它会 reset 掉相应的流。但是即便如此，服务端在收到 RST_STREAM 帧的时候，很有可能已经推了一部分数据了。这种服务端开始推送数据和 RST_STREAM 帧之间的竞争是难以避免的（这是 feature 而不是 BUG）。 服务端推送的实现标识依赖资源 W3C候选推荐标准（https://www.w3.org/TR/preload/）建议了依赖资源的两种做法：文件内标签和HTTP头部携带, 表示该资源后续会被使用, 可以预请求, 关键字preload修饰这个资源, 写法如下： a) 静态Link标签法: b) HTTP头表示法： Link: &lt;push.css&gt;; rel=preload; as=style 其中rel表明了资源&lt;/push.css&gt;是预加载的，as表明了资源的文件类型。另外，link还可以用nopush修饰，表示浏览器可能已经有该资源缓存，指示有推送能力的服务端不主动推送资源，只有当浏览器先检查到没有缓存，才去指示服务端推送资源，nopush格式写成： Link: &lt;/app/script.js&gt;; rel=preload; as=script;nopush。 总结一下： 客户端向服务端请求一个html文件，服务端进行推送，并把相关的资源(或者资源链接)推送给客户端(通过HTTP请求头的LINK或者HTML中的preload)。 客户端知道了服务端要推送相关资源，可以选择接收和不接收。如果客户端不接收，可以通过 RST_STREAM 帧告诉服务端，服务端会停止推送。 服务端为了避免重复推送，可以在请求头的LINK中加上nopush，服务端看到nopush后会检查自己是否有相关资源，然后选择要不要服务端推送。 参考文章： 1.HTTP/2 头部压缩技术介绍 2.一文读懂 HTTP/2 及 HTTP/3 特性 3.[哈夫曼编码的作用 4.HTTP/2之服务器推送(Server Push)最佳实践 5.HTTP/2 简介","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://jrr997.github.io/blog/tags/HTTP/"}]},{"title":"HTTP1.1特性","date":"2021-03-10T11:50:19.000Z","path":"2021/03/10/HTTP1-1/","text":"文章摘要：了解HTTP1.1的新特性HTTP1.1新特性HTTP1.1特性： 默认长连接：新增Connection字段，可以设置keep-alive值保持连接不断开。 管道化：可以在发送一个请求后继续发送第二个请求，不必等第一个请求的响应。 缓存处理：新增字段cache-control，ETag。 缓存： 强缓存：expires(HTTP1.0)、cache-control(HTTP1.1) 在cache-control中， 有max-age表示过期时间是时间戳。 no-store表示不使用缓存， no-cache表示不使用协商缓存 协商缓存：Last-Modified(HTTP1.0)和If-modified-since，Etag(HTTP1.1)和If-none-match。 注意：cache-control优先级比expires高。","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://jrr997.github.io/blog/tags/HTTP/"}]},{"title":"Vue源码阅读(4)之AST","date":"2021-02-27T14:05:49.000Z","path":"2021/02/27/vue-src-readding-4/","text":"简介：编译的过程就是把模板变成render函数. Vue.js 提供了 2 个版本，一个是 Runtime + Compiler 的，一个是 Runtime only 的，前者是包含编译代码的，可以把编译过程放在运行时做，后者是不包含编译代码的，需要借助 webpack 的 vue-loader 事先把模板编译成 render函数。 编译过程vue的编译过程主要分为三步： 解析模板字符串生成AST 1const ast = parse(template.trim(), options) 优化语法树 1optimize(ast, options) 生成代码 1const code = generate(ast, options) parse什么是ASTAST是抽象语法树，它具体是这样的： 123&lt;ul :class=\"bindCls\" class=\"list\" v-if=\"isShow\"&gt; &lt;li v-for=\"(item,index) in data\" @click=\"clickItem(index)\"&gt;{{item}}:{{index}}&lt;/li&gt;&lt;/ul&gt; 经过 parse 过程后，生成的 AST 如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152ast = { 'type': 1, 'tag': 'ul', 'attrsList': [], 'attrsMap': { ':class': 'bindCls', 'class': 'list', 'v-if': 'isShow' }, 'if': 'isShow', 'ifConditions': [{ 'exp': 'isShow', 'block': // ul ast element }], 'parent': undefined, 'plain': false, 'staticClass': 'list', 'classBinding': 'bindCls', 'children': [{ 'type': 1, 'tag': 'li', 'attrsList': [{ 'name': '@click', 'value': 'clickItem(index)' }], 'attrsMap': { '@click': 'clickItem(index)', 'v-for': '(item,index) in data' }, 'parent': // ul ast element 'plain': false, 'events': { 'click': { 'value': 'clickItem(index)' } }, 'hasBindings': true, 'for': 'data', 'alias': 'item', 'iterator1': 'index', 'children': [ 'type': 2, 'expression': '_s(item)+\":\"+_s(index)' 'text': '{{item}}:{{index}}', 'tokens': [ {'@binding':'item'}, ':', {'@binding':'index'} ] ] }]} 如何生成AST？主要通过正则匹配来解析模板，流程图如下： optimize（优化AST）为什么要优化AST？因为Vue是数据驱动、响应式的，但是我们的模板并不是所有数据都是响应式的，也有很多数据是首次渲染后就永远不会变化的，那么这部分数据生成的 DOM 也不会变化，我们可以在 patch 的过程跳过对他们的比对。 如何进行优化？optimize 的过程，就是深度遍历这个 AST 树，去检测它的每一颗子树是不是静态节点，如果是静态节点则它们生成 DOM 永远不需要改变，这对运行时对模板的更新起到极大的优化作用。 我们通过 optimize 我们把整个 AST 树中的每一个 AST 元素节点标记了 static 和 staticRoot，它会影响我们接下来执行代码生成的过程。 generate这里就是把经过优化的AST转化为render函数。","tags":[{"name":"Vue","slug":"Vue","permalink":"https://jrr997.github.io/blog/tags/Vue/"}]},{"title":"Vue源码阅读(3)之响应式原理","date":"2021-02-22T11:25:28.000Z","path":"2021/02/22/vue-src-readding-3/","text":"简介本篇文章属于新手向，着重点在理解Vue响应式系统中的Observer、Dep、Watcher,这是理解响应式源码的关键。因此这篇文章不会在分析源码上花很多功夫。 Object.defineProperty我们都知道Vue的响应式原理是通过Object.defineProperty修改get和set方法来实现的，当我们访问一个变量时就会执行get方法，当我们修改一个变量时会执行set方法。为了实现响应式，我们可以在get方法中收集依赖，这样就能知道哪些数据依赖当前数据。当数据发生变化时，set方法通知依赖者(watcher)进行数据更新。 Observer就是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新。 在介绍observer前，先要了解initState()的过程。 initState在new Vue时，会执行_init方法进行初始化，当中有一个initState方法，主要是对 props、methods、data、computed 和 wathcer 等属性做了初始化操作。这里我们重点分析 props 和 data。 initProps 遍历所有props，调用 defineReactive 方法把每个 prop 对应的值变成响应式。 通过 proxy 把 vm._props.xxx 的访问代理到 vm.xxx 上。 initData 调用 observe 方法观测整个 data 的变化，把 data 也变成响应式。 通过 proxy 把每一个值 vm._data.xxx 都代理到 vm.xxx 上。 这里涉及三个陌生的方法：proxy 、observe和defineReactive，下面分别介绍。 proxy： 123456789export function proxy (target: Object, sourceKey: string, key: string) { sharedPropertyDefinition.get = function proxyGetter () { return this[sourceKey][key] } sharedPropertyDefinition.set = function proxySetter (val) { this[sourceKey][key] = val } Object.defineProperty(target, key, sharedPropertyDefinition)} 简单来讲，创建一个vm.xxx属性，当我们访问和修改这个属性时，其实是在访问和修改vm._data.xxx，这是就是为什么我们能够通过this来访问到data和props。 observe： observe 方法的作用就是给非 VNode 的对象类型数据添加一个 Observer，如果已经添加过则直接返回，否则在满足一定条件下去实例化一个 Observer 对象实例，Observer等一会介绍。 defineReactive： defineReactive 的功能就是定义一个响应式对象，给对象动态添加 getter 和 setter，它的定义在 src/core/observer/index.js 中。 步骤： new Dep()。 拿到 obj 的属性描述符，然后对子对象递归调用 observe 方法。 ObserverObserver步骤： new Dep()。 执行 def 函数把自身实例添加到数据对象 value 的 __ob__ 属性上。 对数据value进行判断，如果是数组则遍历调用observe方法，如果是对象则调用 walk 方法，而 walk 方法是遍历对象的 key 调用 defineReactive 方法，那么我们来看一下这个方法是做什么的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Observer class that is attached to each observed * object. Once attached, the observer converts the target * object's property keys into getter/setters that * collect dependencies and dispatch updates. */export class Observer { value: any; dep: Dep; vmCount: number; // number of vms that has this object as root $data constructor (value: any) { this.value = value this.dep = new Dep() this.vmCount = 0 def(value, '__ob__', this) if (Array.isArray(value)) { const augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) this.observeArray(value) } else { this.walk(value) } } /** * Walk through each property and convert them into * getter/setters. This method should only be called when * value type is Object. */ walk (obj: Object) { const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) { defineReactive(obj, keys[i]) } } /** * Observe a list of Array items. */ observeArray (items: Array&lt;any&gt;) { for (let i = 0, l = items.length; i &lt; l; i++) { observe(items[i]) } }} 依赖收集Dep12345678910111213141516171819202122232425262728293031323334export default class Dep { static target: ?Watcher; // 静态属性target(Watcher类型) id: number; subs: Array&lt;Watcher&gt;; // 一个（Watcher类型）数组 constructor () { this.id = uid++ this.subs = [] } addSub (sub: Watcher) { /* 为后续数据变化时候能通知到哪些 subs 做准备 */ this.subs.push(sub) } removeSub (sub: Watcher) { remove(this.subs, sub) } depend () { if (Dep.target) { Dep.target.addDep(this) } } notify () { /* 所有Watcher的实例对象 */ const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) { subs[i].update() } }} 什么是依赖？ 123&lt;div&gt; &lt;p&gt;{{message}}&lt;/p&gt;&lt;/div&gt; 12345data: { text: 'hello world', message: 'hello vue',} 12345watch: { message: function (val, oldVal) { console.log('new: %s, old: %s', val, oldVal) },} 12345computed: { messageT() { return this.message + '!'; }} 这里可以看到，虽然data中有text和message，但只有message被使用了，因此只有message需要收集依赖。 Dep如何收集依赖? 在getter中收集，当数据被访问时调用dep.depend。 什么是依赖？ 其实就是watcher。 Watcher1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465export default class Watcher { vm: Component; deep: boolean; sync: boolean; deps: Array&lt;Dep&gt;; newDeps: Array&lt;Dep&gt;; depIds: SimpleSet; newDepIds: SimpleSet; before: ?Function; getter: Function; value: any; constructor ( vm: Component, expOrFn: string | Function, cb: Function, options?: ?Object, isRenderWatcher?: boolean ) { this.vm = vm vm._watchers.push(this) /* 监听器的options */ if (options) { this.deep = !!options.deep // 深度监听 // ... this.sync = !!options.sync // 在当前 Tick 中同步执行 watcher 的回调函数，否则响应式数据发生变化之后，watcher回调会在nextTick后执行； } /* Watcher实例持有Dep的实例的数组 */ this.deps = [] // 老的Dep集合 this.newDeps = [] // 触发更新生成的新的Dep集合 this.depIds = new Set() this.newDepIds = new Set() get () { /* 收集Watcher实例,也就是Dep.target */ pushTarget(this) let value const vm = this.vm try { /* this.getter对应就是我们上篇讲到的vm._update(vm._render(), hydrating),_update会生成VNode,在这个过程中会访 问vm上的data，这时候就触发了数据对象的getter，defineReactive中可以发现每个getter都持有一个dep, 因此在触发getter的时候会触发Dep的depend方法，也就触发了Watcher的addDep方法 */ value = this.getter.call(vm, vm) } finally { /* 把 Dep.target 恢复成上一个状态，因为当前 vm 的数据依赖收集已经完成，那么对应的渲染Dep.target 也需要改变 */ popTarget() this.cleanupDeps() } return value } addDep (dep: Dep) { const id = dep.id /* 保证同一数据不会被添加多次 */ if (!this.newDepIds.has(id)) { this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) { /* 把当前的 watcher 订阅到这个数据持有的 dep 的 subs, 目的是为后续数据变化时候能通知到哪些 subs 做准备 */ dep.addSub(this) } } }} watcher中有两个方法: addDep:看看自己依赖谁，然后告诉被依赖者，让自己进入被依赖者的sub名单。这样当被依赖者发生改变时就通知自己更新。 update:当自己需要更新时调用，这个方法会在数据更新后渲染到页面上，并且调用update这个声明周期函数。 总结回顾一下，Vue响应式原理的核心就是Observer、Dep、Watcher。 Observer中进行响应式的绑定，在数据被读的时候，触发get方法，执行Dep来收集依赖，也就是收集Watcher。 在数据被改的时候，触发set方法，通过对应的所有依赖(Watcher)，去执行更新。比如watch和computed就执行开发者自定义的回调方法。 本文参考了https://juejin.cn/post/6844903858850758670#heading-1。","tags":[{"name":"Vue","slug":"Vue","permalink":"https://jrr997.github.io/blog/tags/Vue/"}]},{"title":"Vue源码阅读(2)之组件化","date":"2021-02-21T13:28:51.000Z","path":"2021/02/21/Vue-src-readding-2/","text":"简介组件化是Vue的一个核心思想。所谓组件化，就是把页面拆分成多个组件 (component)，每个组件依赖的 CSS、JavaScript、模板、图片等资源放在一起开发和维护。组件是资源独立的，组件在系统内部可复用，组件和组件之间可以嵌套。 本文主要关注Vue如何创建组件。 createComponent在上一篇文章中介绍过vm._render方法，作用是根据render函数生成VDOM，生成VDOM主要是由vm_render方法中的createElement中的_createElement方法实现的。 _createElement中有一段逻辑是对参数 tag 的判断，如果是一个普通的 html 标签，如div，则会实例化一个普通 VNode 节点，否则通过 createComponent 方法创建一个组件 VNode。 createComponent有三个核心步骤： 构造子类构造函数 安装组件钩子函数 实例化 VNode 下面我会分别介绍这三个步骤。 构造子类构造函数123456const baseCtor = context.$options._base// plain options object: turn it into a constructorif (isObject(Ctor)) { Ctor = baseCtor.extend(Ctor)} 这里 baseCtor 实际上就是 Vue，这个的定义是在最开始初始化 Vue 的阶段，在 src/core/global-api/index.js 中的 initGlobalAPI 函数有这么一段逻辑： 123// this is used to identify the \"base\" constructor to extend all plain-object// components with in Weex's multi-instance scenarios.Vue.options._base = Vue 我们可以注意到context.$options._base和Vue.options._base，前者是实例中取出_base，后者是构造函数中取出_base,那么为什么这两个地方都能取出_base呢？ 实际上在 src/core/instance/init.js 里 Vue 原型上的 _init 函数中有这么一段逻辑： 12345vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || {}, vm) 这样就把 Vue 上的一些 option 扩展到了 vm.$options 上，意思是vm(组件)的options中包含了Vue的options和用户传入的options。 回到Ctor = baseCtor.extend(Ctor)，这里Ctor是Vue的子类，继承了Vue的属性和方法，extend返回的是一个叫Sub的组件构造函数。当我们去实例化Sub时，就会执行 this._init 逻辑再次走到了 Vue 实例的初始化逻辑，这意味着组件的实例化和Vue的实例化相类似。 安装钩子函数12// install component management hooks onto the placeholder nodeinstallComponentHooks(data) 整个 installComponentHooks 的过程就是把 componentVNodeHooks 的钩子函数合并到 data.hook 中，在 VNode 执行 patch 的过程中执行相关的钩子函数。 简单地说是把生成VNode的方法都准备好，准备生成Vnode。 # 实例化VNode12345678const name = Ctor.options.name || tagconst vnode = new VNode( `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`, data, undefined, undefined, undefined, context, { Ctor, propsData, listeners, tag, children }, asyncFactory)return vnode 最后一步非常简单，通过 new VNode 实例化一个 vnode 并返回。需要注意的是和普通元素节点的 vnode 不同，组件的 vnode 是没有 children 的，这点很关键，在之后的 patch 过程中我们会再提。 总结创建一个组件经历了三个步骤： 创建组件的构造函数 执行构造函数，准备好生成Vnode的相关方法。 生成Vnode。 下图是组件创建过程的函数调用栈，通过调用栈我们也能更好地了解组件的创建过程。 Download组件创建过程.png 由下往上看，跟着函数调用栈的顺序，可以看出整个过程是 执行 new Vue，然后初始化 vm 实例，扩展原型方法 执行 mount 函数去解析编译 template 模板 执行 Watcher render 去生成 VNode tree 执行 update 中的 patch 去生成 DOM，如遇到组件 初始化 Sub 构造器 执行 new Sub，初始化组件 vm 实例，扩展原型方法 执行 mount 函数解析编译组件模板，生成组件 VNode tree，最终返回组件 DOM 如再遇组件，则继续递归 可以看出 Vue 的组件生成顺序是由子到父的。 Patch既然有了VNode，下一步应该是调用vm._update来创建真实DOM，这个过程就是patch。 具体的过程就不细说，这里主要注意一个组件中可能又包含另外的组件。如果组件 patch 过程中又创建了子组件，那么DOM 的插入顺序是先子后父。 组件注册全局注册相当于在Vue.options.components注册了一个组件。因为局部组件都会通过Vue.extend创建一个Sub子类(前面介绍过)，而Sub会继承Vue.options.components，这里是通过mergeOptions实现的，前面也简单提到过。 到这里，局部组件就能通过options拿到全局组件。 局部注册Vue.js 也同样支持局部注册，我们可以在一个组件内部使用 components 选项做组件的局部注册，例如： 1234567import HelloWorld from './components/HelloWorld'export default { components: { HelloWorld }} 其实理解了全局注册的过程，局部注册是非常简单的。在组件的 Vue 的实例化阶段有一个合并 option 的逻辑，之前我们也分析过，所以就把 components 合并到 vm.$options.components 上，这样我们就可以在 resolveAsset 的时候拿到这个组件的构造函数，并作为 createComponent 的钩子的参数。 注意，局部注册和全局注册不同的是，只有该类型的组件才可以访问局部注册的子组件，而全局注册是扩展到 Vue.options 下，所以在所有组件创建的过程中，都会从全局的 Vue.options.components 扩展到当前组件的 vm.$options.components 下，这就是全局注册的组件能被任意使用的原因。 异步组件因为我在实战中并没有用过异步组件，这里就先留个坑，只是简单的了解一下异步组件的作用。 在我们平时的开发工作中，为了减少首屏代码体积，往往会把一些非首屏的组件设计成异步组件，按需加载。Vue 也原生支持了异步组件的能力，如下： 123456Vue.component('async-example', function (resolve, reject) { // 这个特殊的 require 语法告诉 webpack // 自动将编译后的代码分割成不同的块， // 这些块将通过 Ajax 请求自动下载。 require(['./my-async-component'], resolve)}) 生命周期生命周期是一个很重要的知识点，我要单独开一篇文章来讲。","tags":[{"name":"Vue","slug":"Vue","permalink":"https://jrr997.github.io/blog/tags/Vue/"}]},{"title":"Vue源码阅读(1)之数据驱动","date":"2021-02-20T15:58:19.000Z","path":"2021/02/20/vue-src-readding-1/","text":"文章摘要：通过阅读Vue源码来深入学习Vue，本文章主要介绍Vue的数据驱动部分源码。作为学习者，这篇文章主要是参考https://ustbhuangyi.github.io/vue-analysis/v2/prepare/ Vue源码阅读一、vue的源码目录设计1234567src├── compiler # 编译相关 ├── core # 核心代码 ├── platforms # 不同平台的支持├── server # 服务端渲染├── sfc # .vue 文件解析├── shared # 共享代码 compilercompiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。 corecore 目录包含了 Vue.js 的核心代码，包括内置组件、全局 API 封装，Vue 实例化、观察者、虚拟 DOM、工具函数等等。 Vue入口Vue入口在 1src/core/instance/index.js 1234567891011121314151617181920212223import { initMixin } from './init'import { stateMixin } from './state'import { renderMixin } from './render'import { eventsMixin } from './events'import { lifecycleMixin } from './lifecycle'import { warn } from '../util/index'function Vue (options) { if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) { warn('Vue is a constructor and should be called with the `new` keyword') } this._init(options)}initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue 这里可以看出Vue是一个构造函数。我们可以看到Vue被传入很多xxxMixin 函数中，这些函数的作用是给Vue.prototype扩展方法。 initGlobalAPI Vue.js 在整个初始化过程中，除了给它的原型 prototype 上扩展方法，还会给 Vue 这个对象本身扩展全局的静态方法，它的定义在 src/core/global-api/index.js 中，全局方法包括set、delete、nextTick等。 二、数据驱动Vue.js 一个核心思想是数据驱动。数据驱动是指数据驱动视图的生成，我们只用修改数据，视图就会发生相应的修改，免去操作DOM来修改视图的步骤。 new Vue 发生了什么？12345678function Vue (options) { if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) { warn('Vue is a constructor and should be called with the `new` keyword') } this._init(options)} 从这里可见，new Vue后执行了this._init方法，并传入了options，而this_init方法主要做了这些事情：合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher 等等。下面是this._init的部分代码。 12345678910111213141516/* istanbul ignore else */ if (process.env.NODE_ENV !== 'production') { initProxy(vm) } else { vm._renderProxy = vm } // expose real self vm._self = vm initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, 'beforeCreate') initInjections(vm) // resolve injections before data/props initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, 'created') 在beforeCreate前，Vue已经初始化了生命周期、时间和渲染，在beforeCreate和created之间有一个initState方法，initState主要是初始化data、props等属性。意思是beforeCreate不能拿到data、props、methods、computed等，要在created中拿。 Vue实例的挂载compiler 版本的 $mount 实现非常有意思，先来看一下 src/platform/web/entry-runtime-with-compiler.js 文件中定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const mount = Vue.prototype.$mountVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component { el = el &amp;&amp; query(el) /* istanbul ignore if */ if (el === document.body || el === document.documentElement) { process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.` ) return this } const options = this.$options // resolve template/el and convert to render function if (!options.render) { let template = options.template if (template) { if (typeof template === 'string') { if (template.charAt(0) === '#') { template = idToTemplate(template) /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; !template) { warn( `Template element not found or is empty: ${options.template}`, this ) } } } else if (template.nodeType) { template = template.innerHTML } else { if (process.env.NODE_ENV !== 'production') { warn('invalid template option:' + template, this) } return this } } else if (el) { template = getOuterHTML(el) } if (template) { /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { mark('compile') } const { render, staticRenderFns } = compileToFunctions(template, { shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments }, this) options.render = render options.staticRenderFns = staticRenderFns /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { mark('compile end') measure(`vue ${this._name} compile`, 'compile', 'compile end') } } } return mount.call(this, el, hydrating)} 在runtime-with-compiler版本的代码中，const mount = Vue.prototype.$mount缓存了runtime-only的$mount，然后重写了$mount方法，这个重写的$mount方法主要做了两件事情： 第一步：Vue实例通过$mount 来挂载vm，且$mount 限制Vue实例不能挂载到body和html根节点上。 第二步：把el和template字符串转化为render方法。Vue 2.0 版本中，所有 Vue 的组件的渲染最终都需要 render 方法。 做完这两步之后，会执行之前缓存的runtime-only的$mount。这个挂载是真正的挂载。 12345678// public mount methodVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component { el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)} 原先的$mount 方法实际上会去调用 mountComponent 方法，这个方法定义在 src/core/instance/lifecycle.js 文件中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273export function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean): Component { vm.$el = el if (!vm.$options.render) { vm.$options.render = createEmptyVNode if (process.env.NODE_ENV !== 'production') { /* istanbul ignore if */ if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== '#') || vm.$options.el || el) { warn( 'You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm ) } else { warn( 'Failed to mount component: template or render function not defined.', vm ) } } } callHook(vm, 'beforeMount') let updateComponent /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { updateComponent = () =&gt; { const name = vm._name const id = vm._uid const startTag = `vue-perf-start:${id}` const endTag = `vue-perf-end:${id}` mark(startTag) const vnode = vm._render() mark(endTag) measure(`vue ${name} render`, startTag, endTag) mark(startTag) vm._update(vnode, hydrating) mark(endTag) measure(`vue ${name} patch`, startTag, endTag) } } else { updateComponent = () =&gt; { vm._update(vm._render(), hydrating) } } // we set this to vm._watcher inside the watcher's constructor // since the watcher's initial patch may call $forceUpdate (e.g. inside child // component's mounted hook), which relies on vm._watcher being already defined new Watcher(vm, updateComponent, noop, { before () { if (vm._isMounted) { callHook(vm, 'beforeUpdate') } } }, true /* isRenderWatcher */) hydrating = false // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook if (vm.$vnode == null) { vm._isMounted = true callHook(vm, 'mounted') } return vm} 这段代码说明了mountComponent做了两件事情： 调用 vm._render生成了VNode，最终调用 vm._update 更新 DOM。 创建Watcher实例，而watcher做又做了两件事情： 一个是初始化的时候会执行回调函数callHook(vm, 'mounted') 二是当vm 实例中的监测的数据发生变化的时候执行回调函数```callHook(vm, ‘beforeUpdate’)`` 总结 模板转化成render函数。 vm._render生成了VNode。 callHook(vm, 'beforeUpdate') vm._update 更新 DOM。 callHook(vm, 'mounted')或者callHook(vm, 'beforeUpdate') vm._render前面提到vm._render,这个方法的作用就是把render函数生成VNode，也就是虚拟DOM。 模板： 123&lt;div id=\"app\"&gt; {{ message }}&lt;/div&gt; 模板转为render函数： 1234567render: function (createElement) { return createElement('div', { attrs: { id: 'app' }, }, this.message)} vm._render方法传入render函数，生成VNode，这里的$createElement就是创建VNode的方法。 1vnode = render.call(vm._renderProxy, vm.$createElement) Virtual DOM首先必须知道为什么需要虚拟DOM？ 因为浏览器的DOM是十分“昂贵”的，真实DOM十分庞大，每个真实DOM都有很多属性和方法。如果我们频繁地更新真实DOM，可能会出现性能问题，因此虚拟DOM就出现了。 那么什么是虚拟DOM？ 虚拟DOM就是描述真实DOM的JS对象，与真实DOM对比起来，虚拟DOM是轻量的。它的核心定义无非就几个关键属性，标签名、数据、子节点、键值等。 虚拟DOM除了它的数据结构的定义，映射到真实的 DOM 实际上要经历 VNode 的 create、diff、patch 等过程。那么在 Vue.js 中，VNode 的 create 是通过之前提到的 createElement 方法创建的，我们接下来分析这部分的实现。 createElementcreateElement做两件事情 children 的规范化 由于 Virtual DOM 实际上是一个树状结构，每一个 VNode 可能会有若干个子节点，这些子节点应该也是 VNode 的类型。_createElement 接收的第 4 个参数 children 是任意类型的，因此我们需要把它们规范成 VNode 类型。 在大多数情况下children都是VNode类型的，但也有例外就是 functional component 函数式组件返回的是一个数组而不是一个根节点，所以会通过 Array.prototype.concat 方法把整个 children 数组打平，让它的深度只有一层。 VNode 的创建 单节点就直接创建一个VNode。 如果是多个节点，会用数组表示，遍历创建VNode。 有时候数组中会嵌套数组，这时用递归。 经过这两个步骤就形成了一个 VNode Tree。 回到 mountComponent 函数的过程，我们已经知道 vm._render 是如何创建了一个 VNode，接下来就是要把这个 VNode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过 vm._update 完成的，接下来分析一下这个过程。 vm._updateVue 的 _update 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候；由于我们这一章节只分析首次渲染部分，数据更新部分会在之后分析响应式原理的时候涉及。_update 方法的作用是把 VNode 渲染成真实的 DOM，它的定义在 src/core/instance/lifecycle.js 中。 首次渲染时vm._update的主要是调用一个patch方法 12// initial rendervm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) 其中patch方法又有一个creatElm方法，作用是根据虚拟DOM创建真实DOM。 简单地讲，在首次渲染时，_update方法根据虚拟DOM数创建一个真实的DOM树然后插入到vm.$el上。 总结那么至此我们从主线上把模板和数据如何渲染成最终的 DOM 的过程分析完毕了，我们可以通过下图更直观地看到从初始化 Vue 到最终渲染的整个过程。 img","tags":[{"name":"Vue","slug":"Vue","permalink":"https://jrr997.github.io/blog/tags/Vue/"}]},{"title":"这是一段很长很长很长很长很长很长很长很长很长很长的文字，用来测试一下标题","date":"2021-02-17T16:26:21.000Z","path":"2021/02/18/test/","text":"测试。","tags":[{"name":"博客","slug":"博客","permalink":"https://jrr997.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"记录博客建站完成","date":"2021-02-17T10:43:02.000Z","path":"2021/02/17/My-New-Post/","text":"文章摘要：记录博客建立完成及过程中遇到的坑 记录一下自己的博客顺利建成！ 本以为用HEXO建个博客挺容易的，结果还是踩了很多坑，不过最终还是顺利完成这个博客。 顺便记录一下这些坑吧。第一个大坑: 首先是博客主题的作者使用ejs来写的，按照主题的文档步骤来还是会报错，错误是_ is not defined in XXX…，这里应该是这个博客最麻烦的地方，我并不知道这个_代表的是什么。 后来据我观察，作者在三个地方都用到 _.XX方法，且三个地方只要执行了就会报错，其中作者用到了_.template和_.isArray()。 我盲猜作者是在ejs中使用了jquery，而这个_就是$的另外写法，但是我在往上并找不到相关的资料(VPN碰巧今晚过期了，因此可能没找详细。) 我也不想在这个地方纠结了，于是只能将计就计，把有_的地方都删掉，或者用顺着思路其他方法代替，终于博客没报错并且能运行。第二个大坑: 点击阅读全文后，并没有显示内容，其中有部分原因是因为这个__，不过解决后还是没显示内容。但是审查元素发现其实内容是有的，这就让我怀疑是display:none，搞的鬼，但事实并不是这样。 后来我改变浏览器窗口大小，当浏览器窗口宽度小于480px时居然显示出了内容，而且还是有动画的，然后我以为是动画的问题，于是往JS的方向找，结果被打脸了——找不到。 那只剩下一个可能了——css的媒体查询。作者是通过opacity来隐藏页面的，我也不知道他为什么要隐藏，我把内容的opacity改成1就能一直显示了。 其实这个博客很多功能还不完善，后续我会接着更新。 最后祝贺自己成功搭建这个博客。","tags":[{"name":"博客","slug":"博客","permalink":"https://jrr997.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]}]